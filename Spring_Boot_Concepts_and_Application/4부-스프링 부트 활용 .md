# 4부: 스프링 부트 활용

4부에서는 스프링 부트가 제공하는 여러 기능을 사용하며 원하는대로 커스터마이징 하는 방법을 알아본다.

## 18. 스프링 부트 활용 소개

|<center>__스프링 부트 핵심 기능__</center>  | <center>__각종 기술 연동__</center>|
|---------------------------------------|---------------------------------|
| SpringApplication                     | 스프링웹 MVC                      |
| 외부설정                                | 스프링데이터                       |
| 프로파일                                | 스프링시큐리티                      |
| 로깅                                   | REST API 클라이언트                |
| 테스트                                  | 다루지않은내용들                    |
| Spring-Dev-Tools                      |                                 |


스프링 부트 핵심 기능이란 어떤 기술(웹 등..)을 사용하더라도 스프링 부트가 기본적으로 제공해주는 핵심 기능들을 말한다.

---

## 19.SpringApplication 1부

https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-spring-application.html#boot-features-spring-application

### SpringinitApplication.class
```java
@SpringBootApplication
@RestController
public class SpringinitApplication {

	public static void main(String[] args) {

		// 기존에 이렇게 실행을 했었는데, 이렇게 하면 스프링 애플리케이션을 커스터마이징 하기 어렵다.
		// SpringApplication.run(SpringinitApplication.class, args);

		// 따라서 스프링 애플리케이션을 만들어서 run 하는 아래와 같은 방식으로 쓰도록 해 본다.
		SpringApplication app = new SpringApplication((SpringinitApplication.class));
		app.run(args);
	}
}
```

 * 기본로그레벨 INFO
   * 뒤에로깅수업때자세히살펴볼예정

<img width="1068" alt="-Ddebug" src="https://user-images.githubusercontent.com/35681772/62432637-ca01a580-b76b-11e9-8e6f-2aaca8cbee60.png">

이렇게 VM 옵션에 ```-Ddebug``` 옵션을 주면 디버그 모드로 애플리케이션이 동작을 한다. 그래서 로그도 디버그 레벨 까지 찍히게 된다.

이렇게 설정을 해 두면 로그들이 잔뜩 찍히게 되는데, __어떠한 자동 설정이 왜 적용이 됐는지, 왜 적용이 안됐는지 에 대한 내용을 알려준다.__ 그래서 자동 설정 관련해서 확인하려면 이 옵션을 주고 파악해 보는것이 좋다.

 * FailureAnalyzer : 에러가 났을 때 에러 메세지를 좀 더 예쁘게 출력해 주는 기능.

 * 배너 : 애플리케이션 실행할 때 나오는 이 그림..
<img width="313" alt="banner" src="https://user-images.githubusercontent.com/35681772/62432774-72b00500-b76c-11e9-8502-fc435dd7afa8.png">

   * banner.txt | gif | jpg | png : 이걸 resource 아래에 만들어서 넣으면 된다.
   * classpath 또는 spring.banner.location
   * ${spring-boot.version} 등의 변수를 사용할 수 있음. 레퍼런스에서 확인할 수 있는데, 일부는 MANIFEST.MF 파일이 만들어 지고 나서 동작하는 것도 있음. 그런 경우 패키징 작업 이후 jar 파일이 생성된 다음부터 뜨게 된다.
   * cf) 
스프링 부트는 패키징을 하면 jar 파일 하나에 모든 의존성을 다 포함해서 딱 하나만 생성이 된다. 그래서 패키징을 할 때 MANIFEST.MF 파일도 만들어 준다. 
   * Banner 클래스 구현하고 SpringApplication.setBanner()로 설정 가능.
   * 배너 끄는 방법

### SpringinitApplication.class
```java
@SpringBootApplication
@RestController
public class SpringinitApplication {

	public static void main(String[] args) {
		SpringApplication app = new SpringApplication((SpringinitApplication.class));
		// 배너를 끄고 싶은 경우
		app.setBannerMode(Banner.Mode.OFF);
		app.run(args);
	}
}
```

 * SpringApplicationBuilder로 빌더 패턴 사용 가능

### SpringinitApplication.class
```java
@SpringBootApplication
@RestController
public class SpringinitApplication {

	public static void main(String[] args) {
		new SpringApplicationBuilder()
				.sources(SpringinitApplication.class)
				.run(args);
	}
}
```


## 20.SpringApplication 2부

https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-spring-application.html#boot-features-application-events-and-listeners

스프링과 스프링 부트에서 제공해주는 다양한 이벤트들이 있다. 이 이벤트 들에는 다양한 '시점'이 있다. 애플리케이션이 잘 구동이 됐을 때, 애플리케이션이 준비가 됐을 때, 실패했을 때 등의 여러 이벤트들이 있다.

### SampleListener.class
```java
// 이렇게 상속 받아서 ApplicationListener 를 만들면 되는데, 중요한 것은 <타입> 을 지정해 줘야 한다.
// 어떤 타입의 이벤트 리스너를 만드는 것인지 알려주는 것.
// 이렇게 구현을 해 주면 명시해준 타입의 이벤트가 발생하면 이 리스너를 실행을 해 주는 것이다.
// 그리고 이렇게 빈으로 등록을 하면 등록 되어있는 빈 중에 해당하는 이벤트에 대한 리스너는 알아서 실행을 해 준다.
// 중요한 것은 애플리케이션 컨텍스트가 만들어 졌는가 만들어지지 않았는가 를 기준으로 큰 차이가 있게 된다.
// 애플리케이션 컨텍스트가 만들어지고 발생하는 이벤트들에 대해서는 그 이벤트의 리스너가 '빈' 인 경우 알아서 호출해줄 수 있는데
// 그 전에 발생하는 이벤트들이 문제다. 아래의 <ApplicationStartingEvent> 이 이벤트도 이 경우에 해당한다.
// 그래서 이 리스너를 빈으로 등록하더라도 실행이 되지 않는다. 이 이벤트는 맨 처음에 발생하는 이벤트이기 때문(애플리케이션 컨택스트 생성 전).
// 따라서 이런 경우엔 직접 등록을 해 줘야 한다.
public class SampleListener implements ApplicationListener<ApplicationStartingEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartingEvent event) {
        System.out.println("=======================");
        System.out.println("Application is starting");
        System.out.println("=======================");
    }
}
```

위의 경우와 같이 애플리케이션 컨텍스트가 만들어 지기 전에 발생하는 이벤트에 대한 리스너는 제 때 실행되지 않는다. 이런 경우 직접 등록을 해 줘야 한다.

 * ApplicationEvent 등록
   * ApplicationContext를 만들기 전에 사용하는 리스너는 @Bean으로 등록할 수 없다.
     * SpringApplication.addListners()

### SpringinitApplication.class
```java
@SpringBootApplication
@RestController
public class SpringinitApplication {

	public static void main(String[] args) {
		SpringApplication app = new SpringApplication(SpringinitApplication.class);
		app.addListeners(new SampleListener());
		app.run(args);
	}
}
```

이렇게 직접 등록을 해 준다면, 앞선 SampleListener 클래스는 빈으로 등록될 필요가 없다. 따라서 @Component 애노테이션을 빼 줘야 한다.

이런 경우가 아니라면 빈으로 등록된 리스너의 경우 잘 작동하게 된다. 이번엔 <ApplicationStartedEvent> 에 대해 테스트 해 보자.

### SampleListener.class
```java
@Component
public class SampleListener implements ApplicationListener<ApplicationStartedEvent> {

    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        System.out.println("=======================");
        System.out.println("Application is started");
        System.out.println("=======================");
    }
}
```

이러면 잘 뜨게 됨.

__이 이벤트가 언제 발생하는가__ 에 주목해서 처리만 해 준다면 별 무리없이 처리가 가능하다.

 * WebApplicationType 설정

 WebApplicationType 으로는 다음 3개가 있다. __NONE, SERVLET, REACTIVE__

 __스프링 웹 MVC 가 존재하면 기본적으로 ```WebApplicationType.SERVLET``` 으로 동작하게 된다.__

 __Spring webflux 가 존재하면 기본적으로 ```WebApplicationType.REACTIVE``` 로 동작하게 된다.__ 단, 이 상황은 '서블릿이 없는 상황에서' webflux 가 존재할 때 이다.

 __둘 다 없으면 WebApplicationType.NONE 으로 동작하게 된다.__

 따라서 '웹 MVC' 도 있고, '웹 플럭스'도 존재하는 상황이라면 타입은 서블릿 으로 동작하게 된다. 이게 기본임.

 만약 웹 MVC 와 리액티브가 다 있지만 서블릿이 아니라 리액티브를 쓰겠다 하면 명시해서 써 주면 된다.

 * 애플리케이션 아규먼트 사용하기
   * ApplicationArguments를 빈으로 등록해 주니까 가져다 쓰면 됨.
 
<img width="272" alt="arguments" src="https://user-images.githubusercontent.com/35681772/62436151-b8bf9580-b779-11e9-822e-17919886b606.png">

애플리케이션 아규먼트란 --로 들어오는 것을 말한다.
-D 로 들어오는 것은 jvm 옵션이다.

```java
@Component
public class SampleListener {
    // 이렇게 생성자가 하나이고, 그 생성자의 파라미터가 빈인 경우 그 빈을 스프링이 알아서 주입을 해 준다.
    public SampleListener(ApplicationArguments arguments) {
        // 그래서 이 빈을 생성할 떄 arguments 에 있는지 없는지 한번 찍어보자.
        System.out.println("foo : " + arguments.containsOption("foo"));
        System.out.println("bar : " + arguments.containsOption("bar"));
    }
}
```

결과는 다음과 같다.

> foo : false
>
> bar : true

결과에서 보는 것 처럼 -D로 들어오는 것은 jvm 옵션으로, --로 들어오는 것만 argument로 쓰는 것이다.

콘솔로 해도 마찬가지의 결과가 나온다. 즉, __jvm 옵션은 ApplicationArgument 가 아니라는 것. 오로지 --로 준 것만 Argument로 받아들여 진다.__

 * 애플리케이션 실행한 뒤 뭔가 실행하고 싶을 때
   * ApplicationRunner (추천) 또는 CommandLineRunner
   * 순서지정가능 @Order


'ApplicationRunner' 의 경우 <ApplicationArguments> 타입으로 (이걸 인자로 받게끔 해서) 메서드를
만들어 준다. 그렇기 때문에 <ApplicationArguments> 타입에서 제공하는 유용한 메서드들을 사용할 수 있다.

### SampleListener.class
```java
@Component
// ApplicationRunner 가 여러개인 경우 아래와 같이 우선순위를 지정할 수 있다. 
// 숫자 낮은게 더 우선순위가 높다.
@Order(1)
public class SampleListener implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("foo : " + args.containsOption("foo"));
        System.out.println("bar : " + args.containsOption("bar"));
    }
}
```

근데 'CommandLineRunner' 를 사용하게 되면 아래와 같이 API 를 사용하지 못하게 된다.

### SampleListener.class
```java  
@Component
public class SampleListener implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        Arrays.stream(args).forEach(System.out::println);
    }
}
```


---

## 21.외부 설정 1부

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config

애플리케이션 설정 파일 : 여러 설정 값들을 애플리케이션 밖 또는 안에다가 정의할 수 있는 기능. 가장 흔히 볼 수 있는 설정 파일로는 'application.properties' 가 있음.

'application.properties' : 자동으로 로딩하는 파일 이름이다. 이 처럼 정의되어 있는 파일 안에다가 key:value 꼴로 정의해두면 애플리케이션 안에서 참조하여 사용이 가능하다.

### application.properties
```
waggs.name = waggs
```

이렇게 정의를 했다면 

### SampleRunner.class
```java
@Component
public class SampleRunner implements ApplicationRunner {

    @Value("${waggs.name}")
    private String name;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=================");
        System.out.println(name);
        System.out.println("=================");
    }
}
```

이렇게 @Value 애노테이션을 사용하여 참조할 수 있다.

이것의 결과는 

```
=================
waggs
=================
```

이렇게 나오게 된다.

근데 위 방법은 아래 우선 순위중 15위에 해당하는 방법이라 그 상위 우선 순위를 가진 방법을 사용하면 밀리게 된다. 가령 터미널에 다음과 같이

```
java -jar target/springinit-0.0.1-SNAPSHOT.jar --waggs.name=YOONSUNG
```

명령어를 치면 분명히 application.properties 파일엔 ```waggs.name = waggs``` 로 되어 있음에도

```
=================
YOONSUNG
=================
```

이런 결과가 나타난다.

위에서 터미널에 커맨드 라인 아규먼트 로 값을 주는 방법은 우선 순위가 4순위이다.

이 방법이 우선 순위가 더 높기 때문에 properties 에 들어 있는 값을 오버라이딩 해서 찍히게 되는 것이다.


### 사용할 수 있는 외부 설정
 * properties
 * YAML
 * 환경 변수
 * 커맨드 라인 아규먼트

### 프로퍼티 우선 순위
  1) 유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties
  2) 테스트에 있는 @TestPropertySource
  3) @SpringBootTest 애노테이션의 properties 애트리뷰트
  4) 커맨드 라인 아규먼트
  5) SPRING_APPLICATION_JSON (환경변수또는시스템프로티) 에 들어있는 프로퍼티
  6) ServletConfig 파라미터
  7) ServletContext 파라미터
  8) java:comp/env JNDI 애트리뷰트
  9) System.getProperties() 자바 시스템 프로퍼티
  10) OS 환경 변수
  11) RandomValuePropertySource
  12) JAR 밖에 있는 특정 프로파일용 application properties
  13) JAR 안에 있는 특정 프로파일용 application properties
  14) JAR 밖에 있는 application properties
  15) JAR 안에 있는 application properties
  16) @PropertySource
  17) 기본 프로퍼티 (SpringApplication.setDefaultProperties)

### Test > SpringinitApplicationTests.class
```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringinitApplicationTests {

	@Autowired
	Environment environment;

	@Test
	public void contextLoads() {
		assertThat(environment.getProperty("waggs.name"))
				.isEqualTo("sheenstar");
	}
}
```

### Test>resources>application.properties
```
waggs.name = sheenstar
```

이렇게 Test 디렉토리 안에 resources 디렉토리를 새로 만들고 그 디렉토리를 Project Structure > Modules > Sources 로 가서 새로 만든 resources 폴더를 Test Resources 로 지정해 준다. 

그리고 위 테스트를 돌리면 ```waggs.name``` 이 sheenstar 로 설정되어 테스트가 꺠지지 않고 통과하는 것을 볼 수 있다.

위 결과는 아래와 같은 흐름에 의해 발생한다.

테스트 코드를 실행 하기 전에 빌드가 된다. 테스트 코드의 빌드를 할 때 source 밑에 있는 것을 빌드를 하고 classpath 에 놓는다. 즉, src > main 디렉토리 아래 java 와 resources 이 디렉토리의 모든 파일이 소스를 빌드한 시점에 classpath 에 들어간다.

그 다음 테스트 코드를 컴파일 한다. 그리고 classpath 에 갔다 놓게 된다. 즉, test 아래 java 와 resources 이 디렉토리의 모든 파일이 classpath 에 들어가게 되는 것이다. 

이 때, application.properties 의 값이 test 의 것으로 바뀌게 되는 것이다.

근데 이 방식을 사용하면 다음과 같은 문제점이 발생할 수 있다.

test 가 아닌 src > main 의 application.properties 에 ```waggs.age``` 를 정의해 두고 SampleRunner 에서 위의 @Value 애노테이션 방식으로 꺼내 썼다고 해 보자. 그래서 SampleRunner 를 돌리면 잘 돌아 간다. 

그리고 test 에서 테스트를 돌려보면 테스트가 깨지가 된다. 테스트의 application.properties 파일이 기존의 것을 덮어 써서 age 가 정의되지 않았는데, Runner에서는 가져다 쓰려고 했으므로 깨지게 되는 것이다.

위와 같이 일종의 '충돌'을 피하기 위해선 test 에 있는 application.properties 파일을 지워버리면 된다. 그러면 빌드시 src > main 의 application.properties 만 클래스 패스에 놓이고 따로 오버라이딩 되지 않기 때문에 충돌이 발생할 여지가 없게 된다.

<br><br>

그리고 다시 우선순위 얘기로 돌아가서

### SpringinitApplicationTests.class
```java
@RunWith(SpringRunner.class)
@SpringBootTest(properties = "waggs.name=callmewaggs")
public class SpringinitApplicationTests {

	@Autowired
	Environment environment;

	@Test
	public void contextLoads() {
		assertThat(environment.getProperty("waggs.name"))
				.isEqualTo("callmewaggs");
	}
}
```

위와 같이 @SpringBootTest 애노테이션의 properties 애트리뷰트 값을 설정해주면 이게 우선순위가 더 높아 덮어 써지게 된다.


하지만 properties 를 따로 명시해 줄 파일들이 너무 많은경우? 한꺼번에 파일로 관리하는게 가장 편하다.

### test > resources > test.properties
```
waggs.name = YOONSUNG
waggs.age = 28
waggs.fullName = ${waggs.name} LEE
```

### test > SpringinitApplicationTests.class 
```java
@RunWith(SpringRunner.class)
@TestPropertySource(locations = "classpath:/test.properties")
@SpringBootTest
public class SpringinitApplicationTests {

	@Autowired
	Environment environment;

	@Test
	public void contextLoads() {
		assertThat(environment.getProperty("waggs.fullName"))
				.isEqualTo("YOONSUNG LEE");
	}
}
```

@TestPropertySource 애노테이션으로 어떤 프로퍼티를 쓸 것인지 명시해 줬으므로 우선 순위도 가장 높고 충돌이 날 가능성도 적은 방법이다.

위의 현상이 발생한 원인은 '같은 위치에' application.properties 파일이 존재하기 때문에 컴파일시 덮어 써 지게 되어 일어나게 된다. 근데 application.properties 파일을 '다른 위치에' 두게 된다면 이런 일은 발생하지 않게 된다.

application.properties 파일이 위치할 수 있는 경로는 아래와 같다.

### application.properties 우선 순위 (높은게 낮은걸 덮어 씁니다.)
1) file:./config/
2) file:./
3) classpath:/config/
4) classpath:/

제일 위에 있는 경로가 가장 우선 순위가 높다.

### 랜덤값 설정하기
 * ${random.*}

### 플레이스 홀더
 * name = keesun
 * fullName = ${name} baik

 ---

## 22.외부 설정 2부

### 타입-세이프 프로퍼티 @ConfigurationProperties

 * 여러 프로퍼티를 묶어서 읽어올 수 있음
   
   같은 키로 시작하는 외부 설정이 있는 경우 묶어서 하나의 빈으로 등록하는 방법.

### src > main > resources > application.properties
```
waggs.name = waggs
waggs.age = ${random.int(0,100)}
waggs.fullName = ${waggs.name} LEE
```


### WaggsProperties.class
```java
@Component
@ConfigurationProperties("waggs")
public class WaggsProperties {

    private String name;

    private int age;

    private String fullName;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }
}
```

이렇게 하나의 클래스에 properties 의 키값에 해당하는 애들을 정의해 줌. 근데 이 상태만으로는 '받아올 수'는 있지만 가져다 쓸 수는 없는 상태이다. 따라서 @Component 애노테이션을 줘서 빈으로 등록해 준다.

빈으로 등록했다면 아래와 같이 @Autowired 로 꺼내 쓰면 된다.

```java
@Component
public class SampleRunner implements ApplicationRunner {

    @Autowired
    WaggsProperties waggsProperties;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=================");
        System.out.println(waggsProperties.getName());
        System.out.println(waggsProperties.getAge());
        System.out.println(waggsProperties.getFullName());
        System.out.println("=================");
    }
}
```

 * 빈으로 등록해서 다른 빈에 주입할 수 있음
   * @EnableConfigurationProperties
   * @Component
   * @Bean

 * 융통성 있는 바인딩
   * context-path (케밥)
   * context_path (언드스코어)
   * contextPath (캐멀)
   * CONTEXTPATH

이건 어떤 의미의 융통성이냐면 
```waggs.full_name = ${waggs.name} LEE```, ```waggs.full-name = ${waggs.name} LEE``` 이렇게도 바인딩을 해 준다는 의미

 * 프로퍼티 타입 컨버전
   * @DurationUnit

application.properties 에 문자열로 입력한 값이 int 타입으로 들어갔기 때문에 컨버젼이 됨을 확인할 수 있음. 스프링 프레임 워크가 제공하는 컨버젼 서비스를 통해서 타입 컨버젼이 일어나는 것이다.

스프링 부트가 제공하는 독특한 컨버젼 타입으로 @DurationUnit 이 있다. 이것은 시간 정보를 받고 싶을때 사용하는데, 아래와 같다.

```java
// ChronoUnit.SECONDS : 아래 값은 '초'로 받겠다 라는 의미
// Duration.ofSeconds(30) : 이 값이 안 들어오면 기본 값은 30초 라는 것.
@DurationUnit(ChronoUnit.SECONDS)
private Duration sessionTimeout = Duration.ofSeconds(30);
```

이렇게 설정해 주고 'application.properties' 파일에 ```waggs.sessionTimeout=25``` 를 주면 아래와 같은 결과가 나옴.

```
=================
waggs
91
waggs LEE
PT25S
=================
```

 * 프로퍼티 값 검증
   * @Validated
   * JSR-303 (@NotNull, ...)

### WaggsProperties.class
```java
@Component
@Validated
@ConfigurationProperties("waggs")
public class WaggsProperties {
    @NotEmpty
    private String name;

    ...
```

이렇게 @Validate 애노테이션과 함께 @NotEmpty 를 준 필드에 대해 

### application.properties
```
waggs.name=
waggs.age=${random.int(0,100)}
waggs.full-name=${waggs.name} LEE
waggs.sessionTimeout=25s
```

Empty 를 주면 아래처럼 에러 메세지를 출력 해 준다.

```
***************************
APPLICATION FAILED TO START
***************************

Description:

Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'waggs' to me.waggs.springinit.WaggsProperties failed:

    Property: waggs.name
    Value: 
    Origin: class path resource [application.properties]:2:0
    Reason: must not be empty


Action:

Update your application's configuration
```

위와 같이 application.properties 를 사용할 때 하나의 프로퍼티에서 grouping 해서 쓰면 자동 완성도, 타입 컨버젼도, @Validation 도 사용할 수 있으므로 더 많은 혜택을 누릴 수 있다.

@Value 라는 애노테이션을 사용하기 보단 이 처럼 하나로 묶어 사용할 수 있게 이 방법이 권장된다.

 * 메타 정보 생성

 * @Value
   * SpEL 을 사용할 수 있지만...
   * 위에 있는 기능들은 전부 사용 못 합니다.

@Value 애노테이션은 SpEL 을 사용할 수 있는 장점이 있을 뿐....


---

## 23.프로파일

스프링 프레임 웤에서 제공해주는 기능이다. 어떤 특정한 프로파일에서만 동작하게 하고 싶은 경우, 특정 프로파일에만 특정 빈을 등록하고 싶은 경우 등에 사용..

### BaseConfiguration.class 
```java
@Profile("prod")
@Configuration
public class BaseConfiguration {

    @Bean
    public String hello() {
        return "hello";
    }
}
```

### TestConfiguration.class 
```java
@Profile("test")
@Configuration
public class TestConfiguration {

    @Bean
    public String hello() {
        return "hello";
    }
}
```

위와 같은 두개의 프로파일이 존재하는 경우, "prod" 라는 프로파일일 때 'BaseConfig..' 설정 파일이 사용이 되고, "test" 프로파일일 때 'TestConfig..' 설정 파일이 사용이 된다.

@Profile 애노테이션은 어디에?
 * @Configuration
 * @Component

어떤 프로파일을 활성화 할 것인가?
 * spring.profiles.active


```java
@Component
public class SampleRunner implements ApplicationRunner {

    @Autowired
    private String hello;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("=================");
        System.out.println(hello);
        System.out.println("=================");
    }
}
```

그냥 이렇게만 하고 @Autowired 로 주입받으려 하면 에러가 난다. 따라서 application.properties 에 ```spring.profiles.active=prod``` 로 내가 사용할 프로파일을 명시해주면 된다.

하지만 결국 이 프로파일 설정도 application.properties 안에 위치해 있다. 따라서 똑같이 __우선 순위__ 에 영향을 받는다.

그렇기 때문에 커맨드 라인 아규먼트로 ```spring.profiles.active=test``` 를 주게 되면 프로파일이 test 로 지정이 된다.

```
java -jar target/springinit-0.0.1-SNAPSHOT.jar --spring.profiles.active=test
```

'application-prod.properties' 와 'application-test.properties' 를 따로 만들어서 각 프로파일 용 프로퍼티를 따로 정의해 줄 수도 있다. 

이게 application.properties 보다 우선 순위가 높은 방법이라 동일하게 위 처럼 커맨드 라인 아규먼트로 인자를 주게 되면 만들어 둔 프로파일용 프로퍼티가 적용되는 것을 확인할 수 있다.

어떤 프로파일을 추가할 것인가?
 * spring.profiles.include

```
waggs.full-name=waggsProd
spring.profiles.include=proddb
```

이렇게 설정해 두면 proddb 프로파일을 다시 활성화 하라는 의미가 된다.

프로파일용 프로퍼티
 * application-{profile}.properties

---

## 24.로깅 1부: 스프링 부트 기본 로거 설정

### 로깅 퍼사드 VS 로거
 * __Commons Logging​__(스프링 부트 디폴트 셋팅), SLF4j(하지만 결국 이걸 쓰게 됨) : 실제 로깅을 하는 게 아니고 로거 API 를 추상화 해 놓은 인터페이스. 그래서 주로 프레임 웤들은 로깅 퍼사드를 사용해서 코딩을 한다. 이렇게 _로깅 퍼사드_ 를 쓰는 이유는 로깅 퍼사드들 아래의 로거들(아래 JUL, Log4J2... 등)을 바꿔 낄 수 있도록 해 주기 때문이다. 프레임 웤을 사용하는 어플리케이션들이 로거를 원하는 것으로 쓸 수 있도록 제공해 주기 위해서.

 * JUL, Log4J2, __Logback__ : 구현체 로거 들.

### 스프링 5에 로거 관련 변경 사항

 * https://docs.spring.io/spring/docs/5.0.0.RC3/spring-framework-reference/overview.html#overview-logging

 * Spring-JCL : 자카르타 커먼스 로딩. 코드를 컴파일 시점에 Commons Logging 에서 SLF4J나 Log4J2 로 변경할 수 있는 모듈이 등장함.
   * Commons Logging -> SLF4j or Log4j2
   * pom.xml에 exclusion 안해도 됨.

정리하자면 스프링 부트는 Commons Logging 을 쓴다. 하지만 SLF4J 를 써도 상관 없다. SLF4J 는 또 Logback 으로 보낸다.

__결과적으로 Logback 이 로그를 찍는다.__

### 스프링 부트 로깅
 * 기본 포맷 : __날짜 / 시간 / 로그 레벨 / PID / 쓰레드 이름 / 풀 패키지 경로 및 클래스 이름 / 메세지__ 
 * --debug (일부 핵심 라이브러리만 디버깅 모드로)
 * --trace (전부 다 디버깅 모드로)
 * 컬러 출력: spring.output.ansi.enabled
 * 파일 출력: logging.file 또는 logging.path. 'application.properties' 에 ```logging.path=logs``` 이렇게 적어주면 아래와 같이 로그 파일이 생성됨.
 
 <img width="222" alt="logs" src="https://user-images.githubusercontent.com/35681772/62667506-e4818c00-b9c2-11e9-9460-946e986c5f09.png">

 * 로그 레벨 조정: logging.level.패키지 = 로그 레벨. 'application.properties' 에 ```logging.level.me.waggs.springinit=DEBUG``` 옵션을 주면 springinit 패키지는 DEBUG 레벨로 로깅을 하겠다는 의미.

### SampleRunner.class
 ```java
 @Component
public class SampleRunner implements ApplicationRunner {

    private Logger logger = LoggerFactory.getLogger(SampleRunner.class);

    @Autowired
    private String hello;

    @Autowired
    private WaggsProperties waggsProperties;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        logger.info("=================");
        logger.info(hello);
        logger.info(waggsProperties.getFullName());
        logger.info("=================");
    }
}
 ```

 이런식으로 사용할 수 있다.


---

## 25.로깅 2부: 커스터마이징

https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html

### 커스텀 로그 설정 파일 사용하기
 * Logback (추천): logback-spring.xml - Logback 이 추천되는 이유는 extension 들을 제공해주기 때문(profile, environmentVariable...) 

### logback-spring.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/base.xml"/>
    <logger name="me.waggs" level="DEBUG"/>
</configuration>
```

이런식으로 커스텀하게 관리해 줄 수 있다.

 * Log4J2: log4j2-spring.xml
 * JUL (비추): logging.properties
 * Logback extension
   * 프로파일 <springProfile name=”프로파일”> : 특정 프로파일일 때만 로그 셋팅을 먹일 수 있다.
   * Environment 프로퍼티 <springProperty> : 프로퍼티 값들을 노출시켜 사용할 수 있다.

### 로거를 Log4j2로 변경하기
 * https://docs.spring.io/spring-boot/docs/current/reference/html/howto-logging.html#howto-configure-log4j-for-logging

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-log4j2</artifactId>
        </dependency>
```

이런식으로 디폴트로 제공되는 로깅 기능을 빼고 log4j2 를 추가해 주면 된다.

---

## 26.테스트

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing

### 시작은일단 spring-boot-starter-test를 추가하는 것 부터
 * test 스콥으로 추가. 아래 의존성이 있어야 됨.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```


### @SpringBootTest
 * @RunWith(SpringRunner.class)랑 같이 써야 함.
 * 빈 설정 파일은 설정을 안 해주나? 알아서찾습니다. (@SpringBootApplication)
 * webEnvironment
   * MOCK: mock servlet environment. 내장 톰캣 구동 안 함.
   * RANDON_PORT, DEFINED_PORT: 내장 톰캣 사용 함.
   * NONE: 서블릿 환경 제공 안 함.

### SampleControllerTest.class
```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class SampleControllerTest {

}
```

이게 가장 기본 형태. 일단 이렇게 작성해 놓고 나머지를 써 내려가야 한다.

### webEnvironment = SpringBootTest.WebEnvironment.MOCK 일 때 즉, web environment가 MOCK 으로 잡혀있을 때 테스트 할 수 있는 방법

```java
@RunWith(SpringRunner.class)
// webEnvironment = SpringBootTest.WebEnvironment.MOCK 이게 디폴트로 설정이 되어 있다.
// 이렇게 하면 서블릿 컨테이너가 테스트 용으로 뜨지 않고 서블릿이 Mocking 한 게 뜬다.
// 그래서 Dispatcher Servlet이 Mocking 된 게 만들어 져서 Dispatcher Servlet 과 interaction 하려면
// Mock MVC 라는 클라이언트를 사용해야 한다.
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
// 그 Mock MVC 를 사용하려면 아래 애노테이션을 반드시 붙여줘야 함.
@AutoConfigureMockMvc
public class SampleControllerTest {

    // 그리고 이렇게 주입받아 쓰면 된다.
    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        // MockMvc 로 컨트롤러에 대해 테스트를 작성하는 방법
        // 이 url 로의 get 요청에 대한 테스트를 수행해라.
        mockMvc.perform(get("/hello"))
                // 그 결과값으로 200 이 나오길 기대하고
                .andExpect(status().isOk())
                // 컨텐츠로 "hello waggs" 를 기대한다.
                .andExpect(content().string("hello waggs"))
                // 그리고 그 요청들을 출력해주면 좋겠다. 는 의미
                .andDo(print());
    }
}
```    


### web environment가 RANDOM_PORT 으로 잡혀있을 때 테스트 할 수 있는 방법 - TestRestTemplate 사용시
```java
@RunWith(SpringRunner.class)
// RANDOM_PORT 를 사용하면 실제 내장 톰켓 즉, 실제 서블릿이 뜨게 된다
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class SampleControllerTest {
    //    그래서 이 때 부턴 mockMvc 를 쓰는게 아니라 RestTemplate 나 테스트용 웹 클라이언트를 사용해야 한다.
    //    이건 내장 톰캣 서버에 요청을 보내서 응답을 확인하는 방식이다.
    @Autowired
    TestRestTemplate testRestTemplate;

    // 근데 만약 지금 이 테스트는 컨트롤러->서비스 단 까지 넘어가서 테스트를 수행하는데, 이 범위를 줄여서
    // 서비스 단 만 테스트를 하려면 이렇게 하면 된다.
    // @MockBean 이라는 애노테이션을 붙혀서 컨트롤러를 MockBean으로 만들면
    // 애플리케이션 컨텍스트에 있는 SampleService 라는 빈을 여기서 만든 MockBean 으로 교체한다.
    // 그래서 실질적으로 컨트롤러는 원본이 아니라 MockSampleService 를 사용하게 된다.
    @MockBean
    SampleService mockSampleService;

    @Test
    public void hello() throws Exception {
        // SampleController 가 사용하는 SampleService 를 mocking 해서 @MockBean 애노테이션을 사용하여 그 빈을 교체한 것이다. 
        when(mockSampleService.getName()).thenReturn("YOONSUNG");
        String result = testRestTemplate.getForObject("/hello", String.class);
        assertThat(result).isEqualTo("hello YOONSUNG");
    }
}
```

### web environment가 RANDOM_PORT 으로 잡혀있을 때 테스트 할 수 있는 방법 - WebTestClient 사용시

```xml
<!--        webFlux 의 web client를 쓰려면 아래 의존성을 추가해 줘야 한다.-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

```
```java
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
public class SampleControllerTest {
    // 자바 5에 추가된 spring mvc webFlux 쪽에 추가된 rest client 중 하나다.
    // 기존의 rest client 는 sync 방식이다. 즉, 요청 하나 보내고 그게 끝날 때 까지 기다린 후 다음 요청을 보낼 수 있는데,
    // 이 web client 라는 것은 async 방식이라 요청을 보내고 기다리는게 아니라 응답이 오면 콜백이 오는 방식.
    // 따라서 테스트 코드에서도 웹 클라이언트랑 비슷한 API 를 사용할 수 있다.
    @Autowired
    WebTestClient webTestClient;

    @MockBean
    SampleService mockSampleService;

    @Test
    public void hello() throws Exception {
        when(mockSampleService.getName()).thenReturn("YOONSUNG");
        webTestClient.get().uri("/hello").exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("hello YOONSUNG");
    }
}
```

### @MockBean
 * ApplicationContext에 들어있는 빈을 Mock으로 만든 객체로 교체 함.
 * 모든 @Test 마다 자동으로 리셋.

 @SpringBootTest 라는 애노테이션은 @SpringBootApplication을 찾아가서 모든 빈들을 스캔을 해서 테스트용 애플리케이션 컨텍스트를 생성하고 모든 빈들을 다 등록을 해 줌.
 
 그리고 MockBean 만 해당 Mock 으로 빈들을 교체를 해 줌.

 그래서 이렇게 많은 빈들이 테스트용으로 등록되는 것이 싫은 경우 아래 처럼 하면 된다.

### 슬라이스 테스트
 * 레이어 별로 잘라서 테스트하고 싶을 때
 * @JsonTest
 * @WebMvcTest
 * @WebFluxTest
 * @DataJpaTest
 * ...

### SampleControllerTest.class
 ```java
@RunWith(SpringRunner.class)
// WebMvcTest 는 슬라이싱 용이다. 그래서
// 이렇게 슬라이싱을 하면 Controller 들만 빈으로 등록이 된다.
// 일반적인 Component 들은 빈으로 등록되지 않는다. - 레퍼런스 참고
@WebMvcTest(SampleController.class)
public class SampleControllerTest {

    @MockBean
    SampleService mockSampleService;

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        when(mockSampleService.getName()).thenReturn("YOONSUNG");
        mockMvc.perform(get("/hello"))
                .andExpect(content().string("hello YOONSUNG"));
    }
}
 ```

---

 ## 27.테스트 유틸
 
  * OutputCapture
  * TestPropertyValues
  * TestRestTemplate
  * ConfigFileApplicationContextInitializer

스프링 테스트가 제공하는 유틸리티들이 있는데, OutputCapture 가 제일 유용하다.

### SampleController.class
```java
@RestController
public class SampleController {

    Logger logger = LoggerFactory.getLogger(SampleController.class);

    @Autowired
    private SampleService sampleService;

    @GetMapping("/hello")
    public String hello() {
        logger.info("holoman");
        System.out.println("skip");
        return "hello " + sampleService.getName();
    }
}
```

### SampleControllerTest.class
```java
@RunWith(SpringRunner.class)
@WebMvcTest(SampleController.class)
public class SampleControllerTest {

    // JUnit 의 Rule 을 확장해서 만든 것.
    // OutputCapture는 로그를 포함하여 콘솔에 찍히는 모든 것을 캡쳐한다.
    @Rule
    public OutputCapture outputCapture = new OutputCapture();

    @MockBean
    SampleService mockSampleService;

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        when(mockSampleService.getName()).thenReturn("YOONSUNG");
        mockMvc.perform(get("/hello"))
                .andExpect(content().string("hello YOONSUNG"));

        assertThat(outputCapture.toString()).contains("holoman").contains("skip");
    }
}
```

## 28.Spring-Boot-Devtools

스프링 부트가 제공하는 옵셔널한 툴. 반드시 써야할 이유는 없음. 기본적으로 적용되는 것들도 아니다.

아래처럼 pom.xml 에 의존성을 추가해 줘야 한다.

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>
```

이 devtools 의존성을 추가 해 주는 순간 기본적으로 적용되는 properties 들이 바뀌는 것들이 있다.

__주로 캐시를 끄는것과 관련이 되어 있는데__ , 개발할 때 캐시가 적용이 되어있으면 변경(바꾼것 들)에 대한 즉각적인 변화가 보여지지 않아 브라우저에서 직접 캐시를 비우거나 하는 귀찮음이 생길 수 있어서 개발할 때 유용하게 변경해 주기 위해 캐시를 꺼 주는 것이다.

 * 캐시 설정을 개발 환경에 맞게 변경.

 * 클래스패스에 있는 파일이 변경 될 때마다 자동으로 재시작.
   * 직접 껐다 켜는거 (cold starts) 보다 빠르다. 왜? : 스프링 부트는 클래스 로더를 두개를 사용한다. 하나는 base class loader(우리가 바꾸지 않는 라이브러리들의 의존성을 읽어들이는), 다른 하나는 restart class loader(직접 만들어 진 애플리케이션에 대한) 이렇게 두가지를 쓴다.
   * 릴로딩 보다는 느리다. (JRebel 같은건아님)
   * 리스타트 하고 싶지 않은 리소스는? spring.devtools.restart.exclude
   * 리스타트 기능 끄려면? spring.devtools.restart.enabled = false

서버를 재 시작 해 주는 기능은 리스타트 기능이고, __브라우저 까지 같이 갱신해 주는 것을 라이브 릴로드__ 라는 기능이다.

 * 라이브 릴로드? 리스타트 했을 때 브라우저 자동 리프레시 하는 기능
   * 브라우저 플러그인 설치해야 함.
   * 라이브 릴로드 서버 끄려면? spring.devtools.liveload.enabled = false

 * 글로벌 설정
   * ~/.spring-boot-devtools.properties : __1순위__ 외부 설정 파일의 위치! 이건 ```spring-boot-devtools``` 의존성이 있을 때 1순위의 우선순위를 갖는다.

 * 리모트 애플리케이션 : 이거는 production 용이 아니다. 위험하다. 운영용이 아니고 개발용.

---

## 29.스프링 웹 MVC 1부: 소개

 * 스프링 웹 MVC
   * https://docs.spring.io/spring/docs/5.0.7.RELEASE/spring-framework-reference/web.html#spring-web

 * 스프링 부트 MVC
   * 자동 설정으로 제공하는 여러 기본 기능 (앞으로 살펴볼 예정)


### test > ... > user > UserControllerTest.class
```java
@RunWith(SpringRunner.class)
// 슬라이싱 테스트. 웹 계층만 테스트 하기 위해
@WebMvcTest(UserController.class)
public class UserControllerTest {
    // 이 객체는 @WebMvcTest 를 사용하면 자동으로 빈으로 만들어 주기 때문에 그냥 빈에 있는것을 꺼내다가 사용하면 됨.
    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        mockMvc.perform(get("/hello"))
                .andExpect(status().isOk())
                .andExpect(content().string("hello"));
    }
}
```

### src > main > ... > user > UserController.class
```java
@RestController
public class UserController {
    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

이렇게 스프링 웹 mvc 기능을 아무런 설정 파일을 작성하지 않아도 스프링 웹 mvc 개발을 바로 시작할 수 있다. 이는 스프링 부트가 제공해 주는 '기본 설정' 때문이다.

External Libries > autoconfigure 에 가보면 
```
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
```
이런게 정의되어 있음. 

이 자동 설정 파일이 적용됐기 때문에 가능한 것이다.


 * 스프링 MVC 확장
   * @Configuration + WebMvcConfigurer

 * 스프링 MVC 재정의
   * @Configuration + @EnableWebMvc

스프링 웹 MVC 가 제공해 주는 기능들을 확장하고 싶을때 다음과 같이 하면 된다.

### src > main > ... > config > WebConfig.class
```java
// '추가적인' 설정을 더 해주고 싶을 때
@Configuration
// 근데 여기다 @EnableWebMvc 를 붙이게 되면 스프링 부트가 제공해주는 모든 MVC 기능은 다 사라지고
// 모든 설정을 직접 다 해야 한다.
// @EnableWebMvc
// 따라서 보통은 이렇게 해 놓고 WebMvcConfigurer 가 제공하는 콜백들을 커스터마이징 하는 방식으로 진행한다.
public class WebConfig implements WebMvcConfigurer {

}
```

---

