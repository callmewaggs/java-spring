# 1부. 스프링 MVC 동작원리

## 3.스프링 MVC 소개

### 스프링 MVC로 웹 애플리케이션 개발하기 소개

### M: 모델 
 * 평범한 자바 객체 POJO
 * 도메인 객체 또는 DTO로 화면에 전달할 또는 화면에서 전달 받은 데이터를 담고 있는 객체.

### src > main > java > ... > Event.class
```java
// 모델. 실제 전달하고자 하는, 이 애플리케이션에서 다루는 POJO 객체.
// 아래처럼 lombok 애노테이션을 사용하면 컴파일을 하면 자동으로 target 디렉토리 밑에
// 필드랑 애노테이션만 붙혔지만 실제 이벤트 클래스 아래에 보면 빌더를 사용할 수 있는 스태틱 클래스들 까지 전부 추가된다.
@Getter @Setter
@Builder @NoArgsConstructor @AllArgsConstructor
public class Event {
    private String name;
    private int limitOfEnrollment;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
}
```


### V: 뷰 - HTML, JSP, ​타임리프​, ...
 * 데이터를 보여주는 역할. 다양한 형태로 보여줄 수 있다. 
 * HTML, JSON, XML, ...

### resources > templates > events.html
```html
<!DOCTYPE html>
<!--타임리프를 쓰려면 먼저 아래처럼 xmlns 를 써서 네임스페이스(ns) 를 정의해 줘야 한다.-->
<!--xmlns:th - th라는 네임스페이스를 정의하겠다.-->
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>이벤트 목록</h1>
    <table>
        <tr>
            <th>이름</th>
            <th>참가 인원</th>
            <th>시작</th>
            <th>종료</th>
        </tr>
<!--        뷰는 아래처럼 뷰 단으로 전달되는 모델에 대한 데이터를 어떻게 보여줄 것인지를 처리하는 것.-->
<!--        뷰랑 모델을 연결해 주는 역할을 컨트롤러가 담당한다.-->
<!--        events 목록에 들어있는 하나의 엘리먼트를 event 로 참조하겠다는 의미-->
<!--        아래 <td> 이 사이에 있는 값은 thymeleaf 가 적용이 안 됐을 때 디폴트로 보여주는 값을 정의해 둔 것.</td>-->
        <tr th:each="event: ${events}">
            <td th:text="${event.name}">이벤트 이름</td>
            <td th:text="${event.limitOfEnrollment}">100</td>
            <td th:text="${event.startDateTime}">2019년 1월 10일 오전 10시</td>
            <td th:text="${event.endDateTime}">2019년 1월 10일 오전 12시</td>
        </tr>
    </table>
</body>
</html>
```


### C: 컨트롤러 - 스프링 @MVC
 * 사용자 입력을 받아 모델 객체의 데이터를 변경하거나, 모델 객체를 뷰에 전달하는 역할.
 * 모델 데이터를 입력 받는 경우에는 아래와 같은 작업이 수행된다.
    * 입력값 검증
    * 입력 받은 데이터로 모델 객체 변경
    * 변경된 모델 객체를 뷰에 전달

### src > main > java > ... > EventController.class
```java
// 스프링 mvc 가 제공하는 @Controller 애노테이션을 붙이면 이 클래스는 mvc 패턴에서 컨트롤러 역할을 하는 클래스가 된다.
@Controller
public class EventController {

    @Autowired
    EventService eventService;

    // RequestMethod 로 GET 요청으로 "/events" 라는 요청이 들어오면 이 핸들러가 그 요청을 처리하는 컨트롤러가 된다.
    @GetMapping("/events")
    public String events(Model model) {
        // Model : 자바에 있는 Map 컬랙션에 우리가 보여줄(화면에 전달할) 데이터를(객체를) 담으면 되는 개념.
        // 모델에 해당하는 event 를 만들어 보자.
        // 모델을 컨트롤러에게 제공할 때 여기서 직접 작성해도 되지만, Service 라는 클래스를 만들어 제공하는것이 일반적이다.
        // 아래처럼 모델에 담아준다.
        model.addAttribute("events", eventService.getEvents());
        // 그리고 아래에서 리턴하는 문자열은 '뷰의 이름' 이 된다.
        return "events";
    }
}
```

### MVC 패턴의 장점
 * __동시다발적(Simultaneous) 개발__ - 백엔드 개발자와 프론트엔드 개발자가 독립적으로 개발을 진행할 수 있다.

 * __높은 결합도__ - 논리적으로 관련있는 기능을 하나의 컨트롤러로 묶거나, 특정 모델과 관련있는 뷰를 그룹화 할 수있다. 

 * __낮은 의존도__ - _뷰, 모델, 컨트롤러는 각각 독립적_ 이다. 뷰, 모델, 컨트롤러 간에 loosely coupled 되어 있다는 얘기다. 모델은 항상 thymeleaf 또는 html 로 만들어 줘야 하는 것은 아니다. JSON 으로 내보낼 수도, XML로 내보낼 수도.. 컨트롤러도 마찬가지다. 서블릿을 사용해서 작성할 수도 있다. 반드시 컨트롤러를 애노테이션 기반으로 작성해야 한다고 생각하면 안된다.

 * __개발 용이성__ - 책임이 구분되어 있어 코드 수정하는 것이 편하다.

 * 한 모델에 대한 여러 형태의 뷰를 가질 수 있다.

### MVC 패턴의 단점
 * 코드 네비게이션 복잡함
 * 코드 일관성 유지에 노력이 필요함. 
 * 높은 학습 곡선

### 참고
 * https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
 * https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html

---

## 4.서블릿 소개

스프링 웹 mvc 는 서블릿 기반으로 웹 애플리케이션을 쉽게 만드는 것을 도와주는 프레임 워크.

그럼 서블릿이란?

> '자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 "서블릿"이라 불린다. __자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.__ 서블릿은 JSP와 비슷한 점이 있지만, JSP가 HTML 문서 안에 Java 코드를 포함하고 있는 반면, 서블릿은 자바 코드 안에 HTML을 포함하고 있다는 차이점이 있다.'

### 가장 기본적인 서블릿 애플리케이션 만들기

### 서블릿 (Servlet)
 * 자바 엔터프라이즈 에디션은 자바로 웹 애플리케이션 개발을 할 수 있는 스팩과 API 제공.
 * 그 중에 가장 중요한 클래스 중 하나가 __HttpServlet__.
 * 요청 당 쓰레드 (만들거나, ​__풀에서 가져다가​__ ) 사용. 하나의 요청을 처리할 때 마다 새로운 프로세스를 만들고 죽이는 식으로 동작하는게 아니라, 하나의 프로세스 내 자원을 공유하는 쓰레드를 만들어서 요청을 처리.

### 서블릿 등장 이전에 사용하던 기술인 CGI (Common Gateway Interface)
 * 요청 당 프로세스를 만들어 사용

### 서블릿의 장점 (CGI에 비해)
 * 빠르다.
 * 플랫폼 독립적
 * 보안
 * 이식성

### 서블릿 엔진 또는 서블릿 컨테이너 (톰캣, 제티, 언더토, ...) : 서블릿 스펙을 구현 및 준수한 컨테이너
 * 세션 관리
 * 네트워크 서비스
 * MIME​ 기반 메시지 인코딩, 디코딩
 * 서블릿 생명주기 관리
 * ...

우리가 만든 서블릿 애플리케이션은 우리가 직접 실행할 수 없다. 서블릿 컨테이너가 실행할 수 있기 때문에 우리는 서블릿 컨테이너를 사용해야 한다. 

### 서블릿 ​생명주기
 * 서블릿 컨테이너가 서블릿 인스턴스의 init() 메소드를 호출하여 초기화 한다.
   * 최초 요청을 받았을 때 한번 초기화 하고 나면 그 다음 요청부터는 이 과정을 생략한다.
   * 그렇기 때문에 서블릿 컨테이너는 최초 모든 서블릿을 모두 호출을 해서 init() 을 호출해 둔 다음 요청이 들어왔을 때 다시 실행하지 않도록 한다. 로딩이 되게끔 요청을 보내놓는 것(init() 과정을 생략하고자).

 * 서블릿이 초기화 된 다음부터 클라이언트의 요청을 처리할 수 있다. 각 요청은 별도의 쓰레드로 처리하고 이 때 서블릿 인스턴스의 service() 메소드를 호출한다.
   * 이 안에서 HTTP 요청을 받고 클라이언트로 보낼 HTTP 응답을 만든다.
   * service()는 보통 HTTP Method에 따라 doGet(), doPost() 등으로 처리를 위임한다.
   * 따라서 보통 doGet() 또는 doPost()를 구현한다.

 * 서블릿 컨테이너 판단에 따라 해당 서블릿을 메모리에서 내려야 할 시점에 destroy()를 호출한다.

---

## 5.서블릿 애플리케이션 개발

### 준비물: 메이븐, 톰캣

### 서블릿 구현

프로젝트 생성시 Spring Initializr 가 아닌 Maven 을 선택하여 만든다. 여기서 'Create from archetype' 을 눌러 'maven-archetype-webapp' 을 사용하여 만들 수 있도록 선택.

archetype 이란 메이븐이 제공하는 미리 만들어 둔 일종의 틀 을 가져다 쓰겠다는 것.

<img width="401" alt="maven_hierarchy" src="https://user-images.githubusercontent.com/35681772/62842346-7d2e4980-bcec-11e9-9539-5fdba4e78fe6.png">

그래서 프로젝트를 만들면 위와 같은 레이어로 프로젝트가 생성된다. 여기서 web.xml 이 파일이 매우 중요.

jsp 가 의존성으로 들어와야 하는데 최초 상태엔 없다. 따라서 pom.xml 에 아래 서블릿 API 의존성을 넣어줘야 한다.

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <!--메이븐 의존성에서의 scope 은 이 의존성을 언제 어떻게 클래스 패스에 넣고 쓸 것이냐 에 대한 것.-->
    <!--위의 junit 의 경우 scope 이 test 인데 그렇기 때문에 src 클래스 패스에서는 쓰지 못한다.-->
    <!--오로지 test 를 실행할 때만 사용할 수 있다.-->
    <!--그래서 provided 의 경우 내가 코딩하는 시점에선 사용할 수 있다.-->
    <!--하지만 런타임 시점 즉, WAR 패키징(프로젝트 패키징) 시점에서는 클래스 패스에서 빠진다.-->
    <!--그리고 '제공 되는' 의존성 이기 때문에 (어디서? 서블릿 컨테이너 가령 톰캣 에서) 굳이 런타임시에도 클래스 패스에-->
    <!--가지고 있지 않아도 된다고 scope 를 제공해 준 것이다.-->
    <scope>provided</scope>
</dependency>
```

이렇게 의존성을 추가해 주면 이제 본격적으로 서블릿 API 를 개발할 수 있다.

src > main 아래 'java' 디렉토리를 새로 생성한 뒤 아래처럼 'project structure' 에서 해당 폴더를 Sources 로 지정해 준다.


<img width="1018" alt="src_directory" src="https://user-images.githubusercontent.com/35681772/62842589-1ad64880-bcee-11e9-8e4f-58eec7d95e73.png">

이렇게 하면 이 java 디렉토리는 source 디렉토리가 됨.



### src > main > me.waggs > HelloServlet.class 
```java
public class HelloServlet extends HttpServlet {
    @Override
    public void init() throws ServletException {
        System.out.println("init");
    }

    // get 요청이 왔을 때.
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("doGet");
        resp.getWriter().println("<html>");
        resp.getWriter().println("<head>");
        resp.getWriter().println("<body>");
        resp.getWriter().println("<h1>Hello Servlet</h1>");
        resp.getWriter().println("</body>");
        resp.getWriter().println("</head>");
        resp.getWriter().println("</html>");
    }

    @Override
    public void destroy() {
        System.out.println("destroy");
    }
}
```

이렇게 서블릿을 만들었는데 이 서블릿을 실행하려면 '톰캣'이 필요하다. 서블릿 독자적으로 실행할 수 있는 방법은 없다. 서블릿 컨테이너인 톰캣에 배포하는 식으로 해야 된다.

그래서 brew로 톰캣을 설치한 다음, 톰캣 폴더에 .sh 실행파일이 있는 경로(```/usr/local/Cellar/tomcat/9.0.22/libexec/bin```)에서 
```chmod +x ./*.sh``` 로 실행 권한을 이 디렉토리에 있는 모든 .sh 파일에 준다.

<img width="1072" alt="conf1" src="https://user-images.githubusercontent.com/35681772/62843121-67238780-bcf2-11e9-8b2a-538f59a5089e.png">

<img width="1072" alt="conf2" src="https://user-images.githubusercontent.com/35681772/62843120-67238780-bcf2-11e9-824e-6497f7938513.png">

그리고 위 처럼 Run configuration 을 설정해 준다. 여기서 Application server 에서 tomcat path 를 지정해 준 다음 우측 하단 OK 위에 FIX 라는 버튼이 뜨는데 거기서 'war exploded' 를 선택해 주면 위의 결과가 나온다.

Application server 는 톰캣 9.0.22 버전이고, 배포(Deployment)를 하는데 톰캣을 띄울 때 javaservletdemo 라는 애플리케이션을 WAR 패키징 즉, WAR로 묶어서 배포하는 방법이 있고 WAR이지만 압축을 풀어 헤친 다음 배포하는 방법(WAR exploded)이 있는데 이 경우 후자에 해당하는 것이다.

Deployment 하단에 보면 Application context 로 그 이름이 지정이 되어있고, 다시 Server 에 와 보면 Open browser 아래 After launch 즉, 실행 직후 열어줄 URL 을 열어 애플리케이션 컨텍스트를 열겠다는것이다.

그 다음 실행 버튼을 누르고 로그를 보면

```
...
Connected to server
[2019-08-12 11:21:36,679] Artifact javaservletdemo:war exploded: Artifact is being deployed, please wait...
...
```

배포가 되었음을 알려준다.

그리고 우리가 만든 애플리케이션을 사용하려면 web.xml 에 등록을 해 줘야 한다.

### 서블릿 등록

### web.xml
```xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

<!--  서블릿을 등록하는 방법.-->
  <servlet>
<!--    서블릿 이름을 지정해 준다.-->
    <servlet-name>hello</servlet-name>
<!--    그리고 그 서블릿 경로를 지정해 준다.-->
    <servlet-class>me.waggs.HelloServlet</servlet-class>
  </servlet>

<!--  그다음 그 서블릿을 매핑을 해 주는데,-->
  <servlet-mapping>
<!--    매핑할 서블릿 이름을 적어주고-->
    <servlet-name>hello</servlet-name>
<!--    어떤 url이 들어왔을때 그 서블릿을 동작시킬 것인지를 적어주는 것이다.-->
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>
</web-app>
```

그리고 http://localhost:8080/javaservletdemo_war_exploded/hello 로 들어가 보면 

<img width="670" alt="hello_servlet" src="https://user-images.githubusercontent.com/35681772/62843390-77d4fd00-bcf4-11e9-8c4f-1859f6589e91.png">

이렇게 서블릿이 나오는 걸 볼 수 있다.

근데 중간에 나오는 애플리케이션 이름이 URL 에 붙으면 길어지니 이걸 설정에서 '/' 루트로 설정해 주고 


<img width="769" alt="root" src="https://user-images.githubusercontent.com/35681772/62843445-cb474b00-bcf4-11e9-8de5-75f85b46ef29.png">

실행하여 URL을 줄여서 사용한다.

그렇게 하고 .../hello 요청을 하는 순간

```
Connected to server
...
init
doGet
```

이렇게 init과 doGet 이 실행 되는 것을 알 수 있다.

이거는 처음 서블릿이 사용될 때 init() 메서드가 호출이 되고, get 요청을 처리하기 위해 doGet() 메서드가 호출 된 걸 알 수 있다.

이걸 새로고침 해서 몇 회간 /hello 요청을 보내보면

```
init
doGet
...
doGet
doGet
```

이렇게 init() 이 최초 호출된 후 더이상 반복해서 호출되지 않는 것을 확인할 수 있다.

이것은 이 서블릿이 한번 초기화가 됐기 때문에 추가적으로 호출이 되지 않는다는 것이다.

그리고 서버를 stop 하면 서블릿 컨테이너를 종료할 때 

```
...
destroy
...
```

destroy 가 호출되며 올라가 있던 서블릿을 내려 놓는것을 확인할 수 있다.

그래서 __우리가 앞으로 사용할 서블릿이 위에서 구현해본 것 같이 HttpServlet 기반으로 구현 되어있다.__

그럼 어떻게 애노테이션 기반으로 @Controller 또는 @RequestMapping 를 사용하여 요청을 처리했을까?

그리고 뷰를 어떻게 ```resp.getWriter().println(...)``` 해서 사용하지 않고 타임리프를 써서 보여줄 수 있었을까? 

그리고 web.xml 을 만든적이 없는데 어떻게 웹 애플리케이션을 잘 띄울수 있었을까?

이것에 대한 대답을 알아보도록 하자.

---

## 6.서블릿 리스너와 필터

### 서블릿 리스너 : 서블릿 컨테이너에서 발생하는 이벤트(서블릿 라이프 사이클 변화, 세션의 변화 등)에 특정한 코드를 실행하는 경우 사용할 수 있는 개념. API가 제공된다.
 * 웹 애플리케이션에서 발생하는 주요 이벤트를 감지하고 각 이벤트에 특별한 작업이 필요한 경우에 사용할 수 있다.
   * 서블릿 컨텍스트 수준의 이벤트
     * 컨텍스트 라이프 사이클 이벤트
     * 컨텍스트 애트리뷰트 변경 이벤트
   * 세션 수준의 이벤트
     * 세션 라이프 사이클 이벤트
     * 세션 애트리뷰트 변경 이벤트 

### MyListener.class 
```java
// 서블릿 컨텍스트의 라이프 사이클을 감지할 수 있는 리스너를 구현
public class MyListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent sce) {
        System.out.println("contextInitialized");
        sce.getServletContext().setAttribute("name", "waggs");
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        System.out.println("contextDestroyed");
        
    }
}
```

이렇게 만든 리스너를 web.xml에 등록해주면 된다.

### web.xml
```xml
<listener>
  <listener-class>me.waggs.MyListener</listener-class>
</listener>  
```

### HelloServlet.class
```java
public class HelloServlet extends HttpServlet {
    @Override
    public void init() throws ServletException {
        System.out.println("init");
    }

    // get 요청이 왔을 때.
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("doGet");
        resp.getWriter().println("<html>");
        resp.getWriter().println("<head>");
        resp.getWriter().println("<body>");
        resp.getWriter().println("<h1>Hello, " + getName() + "</h1>");
        resp.getWriter().println("</body>");
        resp.getWriter().println("</head>");
        resp.getWriter().println("</html>");
    }

    private Object getName() {
        return getServletContext().getAttribute("name");
    }

    @Override
    public void destroy() {
        System.out.println("destroy");
    }
}
```

```
Connected to server
...
contextInitialized
...
init
doGet
...
destroy
contextDestroyed
...
Disconnected from server
```

종료까지 리스너를 활용하여 위와 같은 절차를 거치는 것을 확인할 수 있다. 

리스너는 서블릿 컨테이너 위에 있는 개념이다. 그런 리스너들이 서블릿 컨테이너에 등록되어 있는 개념.

### 서블릿 필터
 * 들어온 요청을 서블릿으로 보내고, 또 서블릿이 작성한 응답을 클라이언트로 보내기 전에 특별한 처리가 필요한 경우에 사용할 수 있다.
 * 한 요청이 들어왔을 때 만들어 둔 특정 서블릿으로 그 요청이 doGet통해 가게 되는데, 이 때 doGet으로 가기 전에 '전처리'를 하고 싶은 경우 또는 응답에 특정 처리를 하고싶은 경우 사용할 수 있는게 서블릿 필터.
 * 여러개의 서블릿에 추가적인 작업을 할 수 있고, 특정 URL 패턴에도 특정 작업을 추가로 할 수 있다.

 * web.xml 에 정의한 순서대로 __체인 형태의 구조 형태__ 로 적용된다. 따라서 반드시 다음 체인으로 넘어가도록 코드를 작성해야 최종 서블릿까지 도달이 가능하다.

<img width="230" alt="chain" src="https://user-images.githubusercontent.com/35681772/62844401-19138180-bcfc-11e9-8886-106adc4041fc.png">


서블릿 필터는 어떤 요청이 들어오면 필터를 거쳐 서블릿으로 도달하는 구조다.



### MyFilter.class 
```java
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("Filter init()");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("Filter");
        // 반드시 중요한게, doFilter 에서 다음 step 으로의 연결을 해 줘야 한다.
        // FilterChain 파라미터를 이용하여 아래처럼 chaining을 해 줘야 한다.
        // 맨 마지막 필터인 경우 doFilter 가 서블릿에 연결이 되게 될 것이다.
        filterChain.doFilter(servletRequest, servletResponse);
    }

    @Override
    public void destroy() {
        System.out.println("Filter destroy()");
    }
}
```

### web.xml
```xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <filter>
    <filter-name>myFilter</filter-name>
    <filter-class>me.waggs.MyFilter</filter-class>
  </filter>

  <filter-mapping>
    <filter-name>myFilter</filter-name>
<!--    myFilter 라는 것을 특정 서블릿에 적용할 것인지, 특정 url 패턴에 적용할 것인지 고를 수 있다.-->
<!--    아래는 hello 라는 서블릿에 적용하겠다는 의미다.-->
    <servlet-name>hello</servlet-name>
  </filter-mapping>

  <listener>
    <listener-class>me.waggs.MyListener</listener-class>
  </listener>
  
  <servlet>
    <servlet-name>hello</servlet-name>
    <servlet-class>me.waggs.HelloServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>
</web-app>

```

```
...
Connected to server
...
contextInitialized
Filter init()
...
init
Filter
doGet
...
destroy
Filter destroy()
contextDestroyed
...
Disconnected from server
```

위 순서대로 필터를 거치게 된다.

### 참고
 * https://docs.oracle.com/cd/B14099_19/web.1012/b14017/filters.htm#i1000654

---

## 7.스프링 IoC 컨테이너연동

### 서블릿 애플리케이션에 스프링 연동하기
 * 서블릿에서 스프링이 제공하는 IoC 컨테이너 활용하는 방법
 * 스프링이 제공하는 서블릿 구현체 DispatcherServlet 사용하기


지금까지 만든 서블릿 애플리케이션에 스프링을 넣어 본다.

스프링을 넣는다? 

1. 스프링이 제공하는 IoC 컨테이너를 사용하겠다. 
2. 스프링 MVC 를 사용하겠다. 

의 의미가 있다.


### ContextLoaderListener
 * 서블릿 리스너 구현체
 * ApplicationContext를 만들어 준다.
 * ApplicationContext를 서블릿 컨텍스트 라이프사이클에 따라 등록하고 소멸시켜준다.
 * 서블릿에서 IoC 컨테이너를 ServletContext를 통해 꺼내 사용할 수 있다.


#### 1. 스프링이 제공하는 Ioc 컨테이너를 사용하는 방법.

먼저 의존성이 필요하다.

### pom.xml
```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <!--스프링 부트를 사용하고 있는게 아니기 때문에 버전을 명시해줘야 한다.-->
    <version>5.1.9.RELEASE</version>
</dependency>
```

### web.xml
```xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

<!--  아래에 추가한 ContextLoaderListener 를 사용해서 빈으로 등록한 HelloService 가 IoC 컨테이너에 들어 있을거고, -->
<!--  그렇게 등록된 빈을 서블릿 컨텍스트를 통해 꺼내서 사용해본다. -->
  
<!--  context-param 의 위치는 filter 보다 먼저 등록되어야 한다. 그래야 오류가 나지 않는다.-->
  <!--  이 ContextLoaderListener 는 스프링 IoC 컨테이너 즉, 애플리케이션 컨텍스트를 서블릿 애플리케이션의 생명 주기에 맞춰서 바인딩 해준다.-->
  <!--  웹 애플리케이션에 등록되어 있는 서블릿들이 사용할 수 있도록 애플리케이션 컨텍스트를 만들어서 그걸 서블릿 컨텍스트에 등록을 해 준다.-->
  <!--  그리고 서블릿이 종료될 시점에 애플리케이션 컨텍스트를 제거해 준다.-->
  <!--  근데 이 ContextLoaderListener는 애플리케이션 컨텍스트를 만들어야 되기 때문에 스프링 설정파일이 필요하다.-->
  <!--  자바 설정파일을 이용한 애플리케이션 컨텍스트를 사용해본다.-->
  <!--  그래서 이 리스너가 사용하는 파라미터들 중 contextClass 를 사용해서 위의 리스터가 만들어주는 애플리케이션 컨텍스트의 타입을-->
  <!--  AnnotationConfigWebApplicationContext 으로 만들어 달라고 지정해 주는 것이다.-->
  <context-param>
    <param-name>contextClass</param-name>
    <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
  </context-param>

  <!--  자바 설정 파일의 위치를 아래처럼 알려주면, 이 정보를 활용해서 ContextLoaderListener 가 AnnotationConfigWebApplicationContext 를 만들때-->
  <!--  이 설정 파일을 가지고 만들게 된다. 그러면 그 애플리케이션 컨텍스트 안에는 HelloService가 빈으로 들어 있게 된다. -->
  <!--  그러면 우리가 만든 서블릿에서는 애플리케이션 컨텍스트를 통해서 HelloService 를 꺼내 사용할 수 있다.-->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>me.waggs.AppConfig</param-value>
  </context-param>

  <filter>
    <filter-name>myFilter</filter-name>
    <filter-class>me.waggs.MyFilter</filter-class>
  </filter>

  <filter-mapping>
    <filter-name>myFilter</filter-name>
    <servlet-name>hello</servlet-name>
  </filter-mapping>

  <!--  스프링이 제공해주는 listener를 사용한다.-->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

  <servlet>
    <servlet-name>hello</servlet-name>
    <servlet-class>me.waggs.HelloServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>/hello</url-pattern>
  </servlet-mapping>
</web-app>
```

### AppConfig.class
```java
// 자바 설정 파일이기 때문에 @Configuration 을 붙여준다.
@Configuration
// 컴포넌트 스캔을 사용해서 빈을 등록시키려 한다.
@ComponentScan
public class AppConfig {
}
```

### HelloService.class
```java
@Service
public class HelloService {

    public String getName() {
        return "waggs";
    }
}
```

### HelloServlet.class
```java
public class HelloServlet extends HttpServlet {
    @Override
    public void init() throws ServletException {
        System.out.println("init");
    }
    
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //    ContextLoaderListener는 애플리케이션 컨텍스트를 서블릿 컨텍스트에 등록해 준다. 
        //    서블릿 컨텍스트란 모든 서블릿들이 사용할 수 있는 공유 정보를 모아둔 저장소 라고 생각하면 된다.
        //    서블릿 컨텍스트에 라는 이름으로 등록을 해 주기 때문에 아래처럼 꺼내 쓸 수 있는 것이다.
        ApplicationContext context = (ApplicationContext) getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
        //    그래서 그렇게 꺼내온 빈을 사용해서 아래처럼 이름을 출력해 본다.
        HelloService helloService = context.getBean(HelloService.class);
        
        //    이렇게 사용한다는 것은 직접 new 를 해서 사용하는 것이 아니라, 
        //    애플리케이션 컨텍스트에 등록된 빈을 꺼내다 쓰는게 되는 new 것이다.
        
        System.out.println("doGet");
        resp.getWriter().println("<html>");
        resp.getWriter().println("<head>");
        resp.getWriter().println("<body>");
        resp.getWriter().println("<h1>Hello, " + helloService.getName() + "</h1>");
        resp.getWriter().println("</body>");
        resp.getWriter().println("</head>");
        resp.getWriter().println("</html>");
    }

    @Override
    public void destroy() {
        System.out.println("destroy");
    }
}
```

이렇게 실행해 보면 /hello 라는 get 요청이 들어오면 ```Hello, waggs``` 라고 출력되는 것을 확인할 수 있다.

근데 서블릿을 만들때마다 불편한 점은 요청 하나 처리할 때 마다 즉, URL 설정 하나당 web.xml 에 추가될 서블릿과 그 서블릿에 대한 매핑 설정이 계속 누적해서 증가하게 된다.

그리고 그러다 보면 여러 서블릿에서 공통적으로 처리하고 싶은 부분에 있어 비효율이 발생할 수 있는데 그걸 개선하기 위한 디자인 패턴으로 __'FrontController'__ 라는 패턴이 있다. 

__'FrontController' 는 모든 요청을 하나의 컨트롤러가 받아서 그 컨트롤러가 요청에 대한 적절한 대응을 다른 서블릿들에게 분배(dispatch)를 하는 식__ 이다.

이렇게 'FrontController' 역할을 하는 서블릿을 스프링은 이미 구현을 해 놨다. 이게 스프링 MVC의 가장 핵심적인 클래스인 __DispatcherServlet__ 이다.


<img width="371" alt="DispatcherServlet" src="https://user-images.githubusercontent.com/35681772/62914612-f0f35380-bdcb-11e9-972d-4827f79c555e.png">

 * https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc​


#### 2. 스프링 MVC 를 사용하는 방법 - 스프링이 제공하는 서블릿 구현체 DispatcherServlet 사용하기

서블릿 컨텍스트에 등록되어 있는 애플리케이션 컨텍스트가 위 그림상 'Root WebApplicationContext' 이다.

__DispatcherServlet은 이 'Root WebApplicationContext' 를 상속받는 애플리케이션 컨텍스트를 하나 더 만든다.__

이렇게 추가적으로 애플리케이션 컨텍스트를 만드는 이유는 

서블릿 컨텍스트에 등록된 'Root WebApplicationContext'는 여러 다른 서블릿에서도 공유해서 쓸 수 있다. scope 자체가 다른 것이다. 

하지만 추가적으로 DispatcherServlet이 만드는 애플리케이션 컨텍스트는 그 DispatcherServlet 안에서만 사용이 가능하도록 scope 이 한정된다.

그래서 여러 DispatcherServlet 에서 공유해서 사용할 빈들이 있는 경우를 커버하기 위해 상속 구조로 동작하는 것이다.

그래서 이 __'Root WebApplicationContext' 에는 '웹'과 관련된 빈들은 등록이 되지 않는다.__ 그림 상에도 Service 와 Repositories 만 등록이 되어 있는것을 볼 수 있다. Service 와 Repositories 는 다른 빈들도 공유해서 사용할 여지가 있기 때문.

그리고 DispatcherServlet 이 만드는 __'Servlet WebApplicationContext' 에는 '웹'과 관련된 빈들이 등록이 되어 있다.__ Controller, View 관련, 등..

이런 '웹' 관련 빈들은 해당 DispatcherServlet에 한정적인 것이다. 이 DispatcherServlet 을 사용하는 방법을 알아보자.

---

## 8.스프링 MVC 연동

스프링 웹 mvc 의 가장 핵심적인 클래스인 DispatcherServlet 을 만들어 놓은 서블릿 웹 애플리케이션에 등록해서 사용해 본다.

이전까지는 ContextLoaderListener 만 사용하여 스프링이 제공하는 IoC 컨테이너를 사용하는 방법에 대해 살펴봤다면, 지금부턴 스프링 웹 mvc 를 이용하는 방법을 다룬다.

<img width="371" alt="DispatcherServlet" src="https://user-images.githubusercontent.com/35681772/62914612-f0f35380-bdcb-11e9-972d-4827f79c555e.png">

 * https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc​

### 서블릿 애플리케이션에 스프링 연동하기
 * 서블릿에서 스프링이 제공하는 IoC 컨테이너 활용하는 방법
 * 스프링이 제공하는 서블릿 구현체 DispatcherServlet 사용하기

### DispatcherServlet
 * 스프링 MVC의핵심.
 * Front Controller 역할을한다.

### 참고
 * http://www.corej2eepatterns.com/FrontController.htm
 * https://www.oracle.com/technetwork/java/frontcontroller-135648.html
 * https://martinfowler.com/eaaCatalog/frontController.html


### HelloController.class 
```java
@RestController
public class HelloController {
    
    @Autowired
    HelloService helloService;
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, " + helloService.getName();
    }
}
```

어떤 요청에 대한 핸들러를 이와 같이 만들고 싶은 경우 __'스프링 mvc'__ 를 사용하여야 하고, __스프링 mvc 를 쓰려면 이 핸들러 쪽으로 요청을 dispatch 해 줄수 있는, 이와 같은 애노테이션을 이해할 수 있는, 그리고 이러한 응답을 http response 로 만들어 줄 수 있는 'DispatcherServlet' 을 사용하여야 한다.__

그래서 DispatcherServlet 을 web.xml 에 등록해 준다.

### AppConfig.class 
```java
@Configuration
// 컴포넌트 스캔은 기본적으로 모든 @Component 애노테이션을 빈으로 등록을 해 주는데,
// 우리는 DispatcherServlet 이 만드는 애플리케이션 컨텍스트에 등록할 빈과, ContextListener 가 만드는 애플리케이션 컨텍스트에 등록할 빈을
// 구분해서 등록하고 싶기 때문에 아래와 같은 옵션을 추가해 준다.
// AppConfig 는 부모쪽(Root WebApplicationContext) 이므로 Service 와 Repository 만 등록하기 위해 컨트롤러는 필터를 사용해 걸러낸다.
// excludeFilters = @ComponentScan.Filter(Controller.class) 이 말인 즉슨 '컨트롤러는 빈으로 등록하지 않겠다' 이다.
@ComponentScan(excludeFilters = @ComponentScan.Filter(Controller.class))
public class AppConfig {
}
```
### WebConfig.class
```java
@Configuration
//디폴트 필터들은 사용하지 않고, 오직 컨트롤러만 스캔해서 빈으로 등록하겠다.
@ComponentScan(useDefaultFilters = false, includeFilters = @ComponentScan.Filter(Controller.class))
public class WebConfig {
}
```

### web.xml
```xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

  <context-param>
    <param-name>contextClass</param-name>
    <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
  </context-param>

  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>me.waggs.AppConfig</param-value>
  </context-param>

  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>

<!--  이렇게 DispatcherServlet 을 사용하더라도 파라미터들을 줄 수 있다. ContextLoaderListener 에서 받은 파라미터와 거의 동일한데,-->
<!--  먼저 계층구조를 만들어 준다. 우리가 만든 빈은 Service 와 Controller 이렇게 두 개가 있는데,-->
<!--  컨트롤러는 DispatcherServlet 이 만드는 애플리케이션 컨텍스트에 등록이 되어야 하고,-->
<!--  서비스는 ContextLoaderListener 가 만드는 애플리케이션 컨텍스트에 등록이 돼야한다.-->
<!--  하지만 두 애플리케이션 컨텍스트는 부모, 자식 관계라서 '웹' 관련 빈들이 DispatcherServlet 이 만드는 애플리케이션 컨텍스트에 등록되어있지 않더라도-->
<!--  참조가 가능하다. 그렇기 때문에 DispatcherServlet 이 만드는 애플리케이션 컨텍스트에 등록된 Controller 들이-->
<!--  ContextListener 가 만드는 루트 애플리케이션 컨텍스트에 등록된 Service 를 참조가 가능한 것이다.-->


<!--  //디폴트 필터들은 사용하지 않고, 오직 컨트롤러만 스캔해서 빈으로 등록하겠다. 라고 선언한 WebConfig 를 DispatcherServlet이 사용해서-->
<!--  애플리케이션 컨텍스트를 만들도록 아래처럼 알려준다.-->
  <servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<!--    만들어 준 설정을 사용하려면 DispatcherServlet 도 마찬가지로 contextClass 를 변경 해 줘야 한다.-->
    <init-param>
      <param-name>contextClass</param-name>
      <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </init-param>
<!--    만들어 준 설정을 알려주는 것.-->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>me.waggs.WebConfig</param-value>
    </init-param>
  </servlet>

<servlet-mapping>
<!--  app 이라는 서블릿을-->
  <servlet-name>app</servlet-name>
<!--  /app 밑으로 들어오는 모든 요청을 처리하도록 하겠다.-->
  <url-pattern>/app/*</url-pattern>
</servlet-mapping>  
</web-app>
```

이렇게 설정을 해 주면 /app 을 달고 들어오는 모든 요청에 대해 DispatcherServlet 을 사용하게 된다.

따라서 가령 /app/hello 가 들어오면 DispatcherServlet 을 사용하면 HelloController 에서 @GetMapping 을 통해 처리하기 때문에 DispatcherServlet 이 만든 애플리케이션 컨텍스트를 사용하게 될 것이다. 하지만 컨트롤러 안에 주입받은 서비스는 부모의 애플리케이션에 들어있기 때문에 거기서 참조하게 될 것이다. 상속 관계이므로 가능하다.

![DispatcherServletResult](https://user-images.githubusercontent.com/35681772/62925360-28262c80-bded-11e9-8855-f4f0ebf21ef6.png)

그래서 실행 시키면 위와 같이 처리가 된다. app 이하의 요청이기 때문에 DispatcherServlet 이 해당 요청에 대한 핸들러를 찾아 처리를 dispatch 한 것이다.

그런데 __DispatcherServlet 에 모든 빈을 다 등록할 수도 있다.__ 굳이 계층 구조를 나눠서 각기 다른 서블릿으로 사용하지 않아도 된다.

### web.xml
```xml
<web-app>
  <display-name>Archetype Created Web Application</display-name>

<!--  이렇게 DispatcherServlet 만 사용해서 애플리케이션 컨텍스트를 만들게 되면, 이 애플리케이션 컨텍스트가 루트 애플리케이션 컨텍스트가 된다.-->
<!--  그래서 모든 빈이 다 이 애플리케이션 컨텍스트 안에 들어가게 된다.-->
  <servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextClass</param-name>
      <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
    </init-param>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>me.waggs.WebConfig</param-value>
    </init-param>
  </servlet>

<servlet-mapping>
<!--  app 이라는 서블릿을-->
  <servlet-name>app</servlet-name>
<!--  /app 밑으로 들어오는 모든 요청을 처리하도록 하겠다.-->
  <url-pattern>/app/*</url-pattern>
</servlet-mapping>
</web-app>
```

### WebConfig.class
```java
@Configuration
// 모든 빈을 스캔하겠다.
@ComponentScan
public class WebConfig {
}
```

이렇게 하면 AppConfig 는 더이상 필요 없게 된다. 실행시키면 정상 작동한다.

최근에 대부분 DispatcherServlet 을 하나만 사용해서 모든 빈을 다 등록해서 처리하는 식이다.

그리고 이 내용은 스프링 부트와는 많이 차이가 있다.

앞서 다룬 내용은 서블릿 컨테이너가 먼저 뜨고 서블릿 컨테이너 안에 서블릿 애플리케이션(ContextListener, DispatcherServlet)을 연동하는 방법이었다.

반대로 스프링 부트는 스프링 부트 애플리케이션이 먼저 뜨고 그 안에 톰캣이 내장서버로 뜨게 된다. 그래서 그 서블릿을 코드로 임베디드 톰캣 안에다가 등록을 하게 된다.

그래서 우리가 다룬 내용은 '서블릿 컨텍스트 안에 스프링이 들어간 구조' 라면 반대로 스프링 부트는 '스프링 부트라는 자바 애플리케이션 안에 톰캣이 들어가 있는 형태' 이다.

---

## 9.DispatcherServlet 동작 원리 1부

어떻게 DispatcherServlet 을 사용하면 핸들러를 애노테이션으로 작성할 수 있는지에 대해 알아본다.

### DispatcherServlet 초기화
 * 다음의 특별한 타입의 빈들을 찾거나, 기본 전략에 해당하는 빈들을 등록한다.
 * HandlerMapping: 핸들러를 찾아주는 인터페이스
 * HandlerAdapter: 핸들러를 실행하는 인터페이스
 * HandlerExceptionResolver
 * ViewResolver
 * ...

@RestController 는 @Controller + @ResponseBody(각 메서드 의) 이다.

HandlerMapping
 * RequestMappingHandlerMapping

HandlerAdapter
 * RequestMappingHandlerAdapter

---

## 10.DispatcherServlet 동작 원리 2부: SimpleController

### HandlerMapping
 * BeanNameUrlHandlerMapping

### HandlerAdapter
 * SimpleControllerHandlerAdapter

### HelloController.class
```java
@Controller
public class HelloController {

    @Autowired
    HelloService helloService;

    @GetMapping("/hello")
    @ResponseBody
    public String hello() {
        return "Hello, " + helloService.getName();
    }

    @GetMapping("/sample")
    public String sample() {
        return "/WEB-INF/sample.jsp";
    }
}
```

### WEB-INF > sample.jsp
```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<h2>Hello Spring MVC!</h2>
</body>
</html>
```

위 sample() 의 경우는 @ResponseBody 를 사용한 리턴이 아니다. 이 경우는 어떻게 동작하는지 디버거를 실행해보면,

앞서 살펴본 @ResponseBody 를 사용한 객체랑 달리 핸들러 어댑터가 처리하고 났을때 ModelAndView 가 null 이 아니다.

이렇게 리턴값에 따라 결과가 달라지게 된다. 다시 말하면,

__@ResponseBody 가 없는 경우 그냥 문자열만 넘기게 되면 이 문자열을 뷰의 이름으로 인식하게 된다.__

그래서 이 문자열에 해당하는 뷰가 핸들러에 의해 찾아지고, ModelAndView 가 더이상 null이 아니게 된다. 어떤 모델 객체를 바인딩 해서 뷰를 렌더링 한다.

그렇기 때문에 만들어 놓은 jsp 파일을 response 에 실어서 보내게 된다.


### DispatcherServlet 동작 순서
1. 요청을 분석한다. (로케일, 테마, 멀티파트 등)
2. (핸들러 맵핑에게 위임하여) 요청을 처리할 핸들러를 찾는다. DispatcherServlet은 디폴트로 두 개의 핸들러 매핑이 등록되어 있다. BeanNameHandlerMapping, RequestMapping 이 등록되어 있다. 그래서 우리가 애노테이션 기반으로 매핑을 할 수 있는 이유가 이 두개의 핸들러 매핑이 등록되어 있기 때문이다.
3. (등록되어 있는 핸들러 어댑터 중에) 해당 핸들러를 실행할 수 있는 “핸들러 어댑터” 를 찾는다.
4. 찾아낸 “핸들러 어댑터” 를 사용해서 핸들러의 응답을 처리한다.
    * 핸들러의 리턴값을 보고 어떻게 처리할지 판단한다.
      * 뷰 이름에 해당하는 뷰를 찾아서 모델 데이터를 랜더링한다.
      * @ResponseEntity 가 있다면 Converter를 사용해서 응답 본문을 만들고.
5. (부가적으로) 예외가 발생했다면, 예외 처리 핸들러에 요청 처리를 위임한다.
6. 최종적으로 응답을 보낸다.

BeanNameHandlerMapping 은 아래처럼 구현되어 있다.

### SimpleController.class 
```java
// 컨트롤러 라는 애노테이션을 사용해서 빈으로 등록을 할 때, 빈 이름에 "simple" 이라는 이름을 준다는 것이다.
// simple 이라는 요청을 처리하는 핸들러가 된다.
@org.springframework.stereotype.Controller("/simple")
public class SimpleController implements Controller {

//    이 경우는 BeanNameUrlHandlerMapping 이 찾아주게 될 것이다.

    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
//        뷰에서 사용할 데이터가 '모델'이다. 모델과 뷰에 대한 정보를 넣어줄 수 있는게 ModelAndView 이다.
//        근데 순서는 뷰 가 먼저 온다.
        return new ModelAndView("/WEB-INF/simple.jsp");
    }
}
```

@ResponseBody 라는 애노테이션을 달고있는 메서드에서 리턴한 값이라면 응답에다 바로 쓰고 ModelAndView 는 null 이 된다.

그런데 그렇지 않은 경우는 ModelAndView 가 null 이 아닌게 된다. 뷰가 null 이 아니고 그 뷰에 렌더링 할 객체는 있을수도, 없을수도 있다.

### HandlerAdapter
 * SimpleControllerHandlerAdapter

이 핸들러 어댑터가 Controller 라는 인터페이스를 구현해서 만든 핸들러를 찾아서 실행해줄 수 있는 어댑터이다. 그래서 응답을 처리하게 되는 것이다.

---

## 11.DispatcherServlet 동작 원리 3부: 커스텀 ViewResolver

### ViewResolver
 * InternalResourceViewResolver

### InternalResourceViewResolver
 * Prefix
 * Suffix

### WebConfig.class
 ```java
@Configuration
// 모든 빈을 스캔하겠다.
@ComponentScan
public class WebConfig {

    //    이렇게 정의를 해 두면 스프링에게 이렇게 알려주는 것이다.
    //    "뷰에 관련된 파일들을 /WEB-INF/ 아래에 넣어두겠다."
    //    "그리고 뷰에 관련된 파일들은 .jsp 로 끝난다"
    //    InternalResourceViewResolver 가 값들의 앞 뒤에 prefix 와 suffix 를 붙여서 해당 경로의 리소스를 찾아 제공해준다.
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
 ```

### SimpleController.class
```java
@org.springframework.stereotype.Controller("/simple")
public class SimpleController implements Controller {

    //    앞서 prefix 와 suffix 를 정의해 뒀기 때문에 아래와 같이 경로 및 확장자를 생략해서 쓸 수 있다.
    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        return new ModelAndView("simple");
    }
}
```

 ---

## 12.스프링 MVC 구성 요소

DispatcherServlet 이 사용하는 여러 인터페이스들에 대해 알아본다. 

<img width="463" alt="DispatcherServlet" src="https://user-images.githubusercontent.com/35681772/63135530-3cdf0c00-c009-11e9-8ac7-6ccc21c142cc.png">

DispatcherServlet은 initStrategises(...){...} 에서 위의 인터페이스들을 모두 초기화한다.

### DispatcherSerlvet의 기본 전략
 * DispatcherServlet.properties

### MultipartResolver
 * 파일 업로드 요청 처리에 필요한 인터페이스
 * HttpServletRequest를 MultipartHttpServletRequest로 변환해주어 요청이 담고 있는 File을 꺼낼 수있는 API 제공.
 * 바이너리 데이터를 분할하여 보내게 되는데, 그래서 이를 처리할 수 있는 특별한 로직이 필요하다. 그런 로직을 거쳐 우리는 손쉽게 데이터만 가져다 쓸 수 있도록 일련의 처리를 MultipartResolver 라는 인터페이스의 구현체에게 위임하는 방식이다.

### LocaleResolver
 * 클라이언트의 위치(Locale) 정보를 파악하는 인터페이스
 * 이 요청이 어느 지역에서 온 것인지 그 지역 정보를 확인한다. 그 지역 정보에 따라서 MessageSource 에 해당하는 적절한 Message로 Resolving 한다.
 * 기본 전략은 요청의 accept-language를 보고 판단.


### ThemeResolver
 * 애플리케이션에 설정된 테마를 파악하고 변경할 수 있는 인터페이스
 * 참고: ​https://memorynotfound.com/spring-mvc-theme-switcher-example/

### HandlerMapping
 * __요청을 처리할 핸들러를 찾는 인터페이스__
 * 기본적으로 두 개가 핸들러 매핑으로 등록된다(RequestMappingHandlerMapping, BeanNameUrlHandlerMapping).

### HandlerAdapter
 * __HandlerMapping이 찾아낸 “핸들러”를 실제로 처리하는 인터페이스__
 * 스프링 MVC ​확장력​의 핵심
 * 여러 스타일(형태)로 정의된 핸들러를 실제로 처리해줄 수 있다.

### HandlerExceptionResolver
 * 요청 처리중에 발생한 에러 처리하는 인터페이스

### RequestToViewNameTranslator
 * 핸들러에서 뷰 이름을 명시적으로 리턴하지 않은 경우, 요청을 기반으로 뷰 이름을 판단하는 인터페이스

### ViewResolver
 * 뷰 이름(string)에 해당하는 뷰를 찾아내는 인터페이스

### FlashMapManager
 * FlashMap 인스턴스를 가져오고 저장하는 인터페이스
 * FlashMap은 주로 리다이렉션을 사용할 때 요청 매개변수를 사용하지 않고 데이터를 전달하고 정리할 때 사용한다.
 * redirect:/events
 * Post 요청을 받은 다음엔 Get 요청으로 Redirect 를 하는데, 중복 form submission 을 방지하기 위한 요청 처리 패턴이다. get 요청을 redirect 할 때엔 redirect:/events/id=200 이런식의 get 요청으로 준다. 하지만 이렇게 redirect 할 때 url path 나 url request parameter 로 주지 않고도 redirect 데이터를 전송해줄 수 있는 기능이 FlashMap 이다. redirect 할 때 데이터 전송을 더 편한 방식을 제공하기 위한 방법.

---

## 13.스프링 MVC 동작 원리 정리
 
### 결국엔 (굉장히 복잡한) 서블릿.
 = DispatcherServlet

결국 스프링 웹 MVC 도 서블릿 기반으로 동작하는 애플리케이션이기 때문에 서블릿 컨테이너가 필요하다.
 
### DispatcherServlet 초기화
  1. 특정 타입에 해당하는 빈을 찾는다.
  2. 없으면 기본 전략을 사용한다. (DispatcherServlet.properties)
 
### 스프링 부트 사용하지 않는 스프링 MVC
  * 서블릿 컨네이너(ex, 톰캣)에 등록한 웹 애플리케이션(WAR)에 DispatcherServlet을 등록한다. 
    * web.xml에 서블릿 등록
    * 또는 WebApplicationInitializer에 자바 코드로 서블릿 등록 (스프링 3.1+, 서블릿3.0+)
  * 세부 구성 요소는 빈 설정하기 나름.
 
### WebApplication.class
```java
// WebApplicationInitializer 를 사용해서 DispatcherServlet을 등록하는 방법.
// web.xml 이 없이도 서블릿을 등록할 수 있다.
// WebApplicationInitializer 인터페이스를 구현하면 된다.
// 이 안에서 서블릿을 만들어서 등록을 해 준다.
public class WebApplication implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        // 이렇게 하면 ApplicationContext 가 만들어진다.
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        context.register(WebConfig.class);
        context.refresh();

        DispatcherServlet dispatcherServlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic app = servletContext.addServlet("app", dispatcherServlet);
        // app 이하의 모든 요청을 DispatcherServlet이 받도록 설정.
        app.addMapping("/app/*");
    }
}
```

위와 같이 web.xml 을 사용하지 않고도 DispatcherServlet을 자바 코드만으로 등록하여 사용할 수 있다.

여기까지는 '스프링 부트 없이' 사용하는 방법이다. 스프링 부트가 없이 사용할 땐 빈에 무엇이 등록되어 있는지가 중요하다. 또 이런 빈이 없다면 DispatcherServlet.properties 에 등록된 것들이 사용된다.

그리고 또 하나 중요한 것은 __'서블릿 컨네이너(ex, 톰캣)에 등록한 웹 애플리케이션(WAR)에 DispatcherServlet을 등록한다.'__ 즉, __톰캣 안에 DispatcherServlet을 등록한다는 것.__

### 스프링 부트를 사용하는 스프링 MVC
  * 자바 애플리케이션에 내장 톰캣을 만들고(애플리케이션에 종속되는 형태) 그 안에 DispatcherServlet을 등록한다.
    * 스프링 부트 자동 설정이 자동으로 해줌.
  * 스프링 부트의 주관(이런게 더 편할 것이다 와 같은..)에 따라 여러 인터페이스 구현체를 빈으로 등록한다.
  * 그렇기 때문에 스프링 부트를 사용한 스프링 MVC 의 경우 딱히 설정을 추가적으로 해 줄 필요가 없다.
  
---

