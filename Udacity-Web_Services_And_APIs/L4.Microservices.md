# L4.Microservices

## 1. Introduction

Developing microservices using Spring boot!!

Steps
1. registry services - allow services to be registered and found by clients that need to call them.
2. how to create a REST API using spring data REST - generates REST APIs from a spring data repository.
3. wrap up with testing

## 2. MSA (Microservices Architecture)

<img width="704" src="https://user-images.githubusercontent.com/35681772/66293136-f3cc7980-e920-11e9-91af-3b17a67e86bd.png">

__N-Tier and monolithic applications__ used to be the de facto standard. In one single binary web artifact, like an EAR or WAR file, there would be a layered architecture with the decomposition of code into more functional components.
 * Presentation Layer
 * Business Process Layer/Service Layer
 * Data Access Layer


<img width="702" src="https://user-images.githubusercontent.com/35681772/66293314-502f9900-e921-11e9-994b-c43ac4d1408d.png">

There are several __disadvantages__ to the n-tier monolithic application architecture:
 * __Tight coupling__ of code which makes changes hard.
 * A single deployment with multiple layers that causes long testing, building, and deployment cycles.
 * A big monolithic application that makes code reuse and sharing of components difficult.

<img width="698" src="https://user-images.githubusercontent.com/35681772/66293503-bd432e80-e921-11e9-8a8e-a21fe1253cb9.png">

__The Microservices Architecture (MSA)__ decomposes systems into discrete, individual, standalone components that can communicate amongst themselves, working together or with external systems.

MSA is a more agile framework that fits well with the cloud-based world and lends itself well to web application development and web service development.

<img width="699" src="https://user-images.githubusercontent.com/35681772/66293725-3f335780-e922-11e9-9011-645b0aaa262a.png">

### Features
 * MSA is very flexible because it supports any language that can communicate via a RESTful endpoint and leverages REST over HTTP.
 * MSA offers agility and systems that are easier to write, test, deploy, and share.
 * MSA provides systems that can better scale to load and demand.
 * MSA provides systems that are resilient because failures are isolated and don’t cascade through the infrastructure.

 Typically, once an application reaches a certain level of scale, it transitions to MSA.


<img width="786" src="https://user-images.githubusercontent.com/35681772/66294158-46a73080-e923-11e9-9c86-54b7cca14886.png">

 Amazon and Netflix are leverage a microservices architecture.

 Amazon - one big monolithic application would be very hard to manage.

 Netflix - converted from a traditional development model with 100 engineers producing a monolithic DVD rental application to a microservices architecture with many small teams responsible for the end-to-end development of hundreds of microservices that work together to stream digital entertainment to millions of Netflix customers.

### Characteristics
  * The phrase micro and microservices isn't related to the lines of code, but is based on the scope of the interface.
  * Each microservice is single-purpose, it's simple, and it has a well-defined interface.
  * It's modular and independent.
  * It has isolated persistence - microservices don't share data. They have their own unique database.
  * Serve as the single system of record for data.

### Case study for microservice goes like

<img width="702" src="https://user-images.githubusercontent.com/35681772/66294503-1b711100-e924-11e9-8d33-6c1845bc1dfe.png">

---

## 3. Spring Cloud & Eureka

An important part in microservices development is to first have a service registry.

<img width="695" src="https://user-images.githubusercontent.com/35681772/66295186-b4ecf280-e925-11e9-8c00-171413420418.png">

Eureka, created by Netflix, is responsible for the registration and discovery microservices. Spring has incorporated Eureka into [Spring Cloud](https://spring.io/projects/spring-cloud), making it even easier to stand up a Eureka server.

Spring cloud is built on top of Spring Boot and utilizes the typical parent and starter palms.

In layman's terms, Netflix Eureka service is responsible for the registration and discovery of microservices.

Every micro service will be registered in the server so that Eureka will know all the client applications running on each port and IP address.

This way, we don't need to know the IP address of each service we create. we just need to know their names and the discovery does the rest.

<img width="696" src="https://user-images.githubusercontent.com/35681772/66394095-1c32a180-ea0f-11e9-8598-73d1af81c24c.png">

Eureka consists of a server and a client-side component. The server component will be the registry in which all the microservices register their availability. The microservices use the Eureka client to register; once the registration is complete, it notifies the server of its existence.

---

## 4. Case Study : Eureka Server

The case study is an online ordering service. There are multiple services that work together to create the system.

 * Item Service
 * Order Service
 * Shipping Service

Each service has its own database. For this case study, instead of building out the entire system, we will focus on the Item Service. The code can be cloned from [GitLab](https://gitlab.com/videolearning/udacity-java/tree/master/Lesson4-microservices).

프로젝트를 열어보면 Eureka 모듈과 items(Microservices) 모듈이 존재한다.

Eureka 모듈부터 살펴보면, pom.xml에 Eureka 서버를 지원하기 위한 의존성들이 들어와 있다.

#### Eureka > pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-netflix-eureka-server</artifactId>
</dependency>
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.4.0-b180725.0427</version>
</dependency>
```

__spring-cloud-starter-config__ : initializes and sets up Spring Cloud.
__spring-cloud-netflix-eureka-server__ : added in an auto configures the Eureka server.
__jaxb-api__ : need this additional dependency in your POM file for the Eureka server to load.

다음으로 application.properties 파일을 보면

#### Eureka > application.properties
```
#configuring the name for the Eureka server and the port
spring.application.name=eureka-server 
server.port=8761

#configuration items for the Eureka client.
#don't register itself as a client
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
logging.level.com.netflix.eureka=ON
logging.level.com.netflix.discovery=ON
```

port 번호가 8761 인데, 이 숫자는 일반적으로 Eureka 서버에 있어 디폴트 값이다.

그리고 그 아래에 ```eureka.client.register-with-eureka=false``` 로 지정해 줌으로써 Eureka client가 클라이언트로 지정되는 옵션을 false로 주었다. 서버로 돌릴것이기 때문.

그리고 그 아래에 logging 옵션을 줘서 더 세부적으로 로그가 찍히도록 옵션을 지정.

#### Eureka > EurekaApplication.java
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }
}
```
__@EnableEurekaServer__ : tells Spring to activate the Eureka server related configuration.

그다음 EurekaServer 를 실행시키면 창이 뜨게 된다. 시스템 상태와 현재시간 등이 표시되고, 가장 중요한 부분은 __Instances currently registered with Eureka__ 이다.

지금까진 __Instances currently registered with Eureka__ 에 어떠한 microservices 를 만들거나 클라이언트로 등록하지 않았기 때문에 아무것도 인스턴스로 들어가 있지 않은 상태다.

The project has the following components:

#### Eureka Module
 * Eureka Registry accessible via http://localhost:8761

#### Items Microservices Module
 * CRUD Repository - ItemRepository.java
 * Domain Entity/Model -Item.java
 * H2 Database accessible via http://localhost:8080/h2/
 * Tomcat Server accessible via http://localhost:8080
 * Items Microservice accessible via http://localhost:8080/items

#### Troubleshooting
You may need this additional dependency in your POM file for the Eureka server to load:

```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.4.0-b180725.0427</version>
</dependency>
```

---

## 5. Lab I: Build a Dog Microservice (Eureka)

### Eureka

__In a new module create the Eureka Service:__

#### Step 1: Create a SpringBoot project that creates a Eureka server.
 * Ensure that you use the proper dependencies in the Maven POM file and the necessary annotations.
 * Make a note of the service URL and add any other necessary details in application.properties.

First, navigate once again to Spring Initializr. You can add the 'Config Client' (for spring-cloud-starter-config) and 'Eureka Server' (for spring-cloud-netflix-eureka-server) dependencies to generate the POM file for this project. Remember that since this is just the Eureka server and not the microservice client you will build later, you won't need dependencies like H2.

Additionally, I added the below additional dependency to my POM file to get the Eureka server up and running:

```xml
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.4.0-b180725.0427</version>
</dependency>
```

From there, navigate to your ```application.properties``` file to add the application name and server port (8761 in the case of a Eureka server, typically). Below, I have also added lines to avoid registering the Eureka server itself as a client, as well as adding some additional logging to help with any potential debugging or information needs.

Now, we just need one import and one annotation added to ```EurekaApplication.java``` - importing ```EnableEurekaServer``` and adding the related annotation.

#### EurekaApplication.java
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }

}
```

#### Step 2: Use a web browser to view the Eureka web console.

Navigate to http://localhost:8761/ on your computer to view the Eureka web console. Note again that Eureka servers are typically put on port 8761, but if you would have used a different server port in ```application.properties```, you would instead navigate to that port.

---

## 7. Spring Data REST : Makes easy to expose a micro service.

Before Spring Data REST came along, writing a REST web service for a multi-domain objects system was tedious and resulted in a lot of boilerplate code and the use of annotation like '@RestController' and '@RequestMapping' in order to create APIs for simple CRUD operations.

<img width="703" src="https://user-images.githubusercontent.com/35681772/67658512-1b9d8300-f99d-11e9-8d8a-aa69a6643259.png">

[Spring Data REST](https://spring.io/projects/spring-data-rest) makes it easy to expose microservices. Spring Data REST builds on top of Spring Data repositories and automatically exports those as REST resources.

The first step is to update the Maven POM file with the Spring Data REST dependency.
```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-rest</artifactId>
        </dependency>
```

So how does Spring Data Rest work?

1. At application startup, Spring Data Rest finds all of the spring data repositories
2. Then, Spring Data Rest creates an endpoint that matches the entity name
3. Next, Spring Data Rest appends an S to the entity name in the endpoint
4. Lastly, Spring Data Rest exposes CRUD (Create, Read, Update, and Delete) operations as RESTful APIs over HTTP

There is no need to create a controller or service layer!

<img width="703" src="https://user-images.githubusercontent.com/35681772/67658968-856a5c80-f99e-11e9-8410-8a3bba4bae23.png">

```java
public interface ItemRepository extends JpaRepository<Item, Integer> { ... }
```

For this repository, Spring Data REST exposes a collection of resources at http://localhost:8080/items

The path is derived from the uncapitalized, pluralized simple class name of the entity class being managed. In this case, 'items'.

It also exposes an item resource for each of the items managed by the repository under the URItemplate / items / ID.

---