# 2부. 스프링 MVC 설정

별 다른 설정을 하지 않아도 DispatcherServlet 에 정의되어 있는 기본 전략을 사용하게 되기 때문에 기본 설정을 굳이 일일이 등록해 주지 않아도 된다. 

이런 기본 전략을 사용할 때엔 기본 전략 클래스들이 가지고 있는 기본값이 적용이 된다. 하지만 앞서 살펴본 'ViewResolver' 의 경우 prefix 와 suffix 가 있지만 없는 상태로 사용하게 되는 것이다. 그래서 원한다면 prefix 와 suffix 를 등록을 할 수 있는 식이다.

따라서 viewResolver 뿐 아니라 거의 대부분의 빈들이 위와 같이 기본 설정 이외의 옵션을 사용할 수 있다.

### HelloController.class 
```java
@Controller
public class HelloController {

    @Autowired
    HelloService helloService;

    /**
     * /hello/1?name=waggs&age=28 요청이 이런식으로 들어온다면
     * @param id
     * @param name
     * @return
     */
    @GetMapping("/hello/{id}")
    @ResponseBody
    public String hello(@PathVariable int id, @RequestParam String name, @ModelAttribute User user) {
        // 핸들러 메서드에 쓸 수 있는 Argument 에 여러가지들이 있다.
        // @PathVariable 에서 {id} 로 넘어온 값을 주입받고 싶은 경우 위와 같이 설정해 준다.
        // 또는 @RequestParam 을 사용해서 위의 name 에 해당하는 값을 받을 수도 있다.
        // 만약 name & age 에 해당하는 변수의 값들을 뭉쳐서 한꺼번에 받고싶은 경우 @ModelAttribute를 사용할 수 있다.
        // @ModelAttribute 를 써서 name 과 age 에 해당하는 값들을 User 라는 것으로 묶어서 받아올 수도 있다.
        return "Hello, " + helloService.getName();
    }

    @GetMapping("/sample")
    public String sample() {
        return "sample";
    }
}
```

### HelloController.class
```java
@Controller
public class HelloController {

    @Autowired
    HelloService helloService;

    @GetMapping("/hello/{id}")
//    @RequestBody 가 있는 경우 응답을 보낼 때 messageConverter 가 사용되게 된다.
    @ResponseBody
    public String hello(@RequestBody String body) {
//        이런식으로 @RequestBody 를 사용하게 되면 메세지 본문에 들어오는 내용을 바인딩 받을 수 있다.
//        요청 본문에 있는 메세지를 파라미터에 바인딩 시켜준다.
        return "Hello, " + helloService.getName();
    }

    @GetMapping("/sample")
    public String sample() {
        return "sample";
    }
}
```

### WebConfig.class
```java
@Configuration
@ComponentScan
public class WebConfig {

    @Bean
    public HandlerMapping handlerMapping() {
        // DispatcherServlet 내부에서 보면 아래처럼 new 해서 곧장 리턴해주는 것 처럼 사용하고 있다.
        // 그래서 설정해 줄 수 있는 옵션은 직접 확인해봐야 한다.
        RequestMappingHandlerMapping handlerMapping = new RequestMappingHandlerMapping();
        // handlerMapping 은 어떤 요청이 들어왔을 떄 그 요청을 처리할 수 있는 핸들러를 찾아주는 인터페이스다.
        // 이 interceptor는 필터와 비슷하게 어떤 요청이 들어왔을 때 특정 핸들러가 일을 처리하기 전/후에 특정한 일을 처리할 수 있다.
        // interceptor는 빈으로 등록될 수 있어 스프링 IoC 컨테이너가 제공하는 장점을 더 사용할 수 있어 더 유연할 수 있다.
        handlerMapping.setInterceptors();
        // Order로 여러 핸들러 매핑간 우선순위를 지정해 줄 수 있다.
        handlerMapping.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return handlerMapping;
    }

    @Bean
    public HandlerAdapter handlerAdapter() {
        // HandlerAdapter 도 마찬가지이다.
        RequestMappingHandlerAdapter handlerAdapter = new RequestMappingHandlerAdapter();
        // ArgumentResolver 를 설정을 해서 원하는 추가적인 Argument 를 정의할 수 있다.
        // handlerAdapter.setArgumentResolvers(...);
        
        return handlerAdapter;
    }

    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

그래서 위와 같이 HandlerMapping 의 경우나 HandlerAdapter 의 경우처럼 모든 설정을 일일이 해 주려면 결국 빈 설정을 직접 해야한다. DispatcherServlet 의 기본 전략에 의존하기는 힘들다.

---

## 14. 스프링 MVC 구성 요소 직접 빈으로 등록하기

@Configuration을 사용한 자바 설정 파일에 직접 @Bean을 사용해서 등록하기

### WebConfig.class
```java
@Configuration
@ComponentScan
public class WebConfig {

    // @EnableWebMvc 를 사용하지 않고 빈을 직접 등록해서 웹 mvc 를 설정하는 단계.
    // 이 단계에서 빈으로 설정한 것은 들어가고, 설정하지 않은 것들은 DispatcherServlet.properties 에 있는 기본 설정을 사용한다.
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

근데 이 방법이 가장 로우레벨로 설정을 해 주는 것이다. 스프링 부트가 나오기 이전에도 이런 방식으로 일일이 설정을 해 주지는 않았다.

이 방법보다 조금 더 수월하게 설정을 해 줄 수 있는 방법을 스프링 mvc 가 제공해 주는 방법에 대해 알아보자.

---

## 15. @EnableWebMvc

애노테이션 기반 스프링 MVC를 사용할 때 편리한 웹 MVC 기본 설정

일일이 빈으로 등록하기 보다는 조금 더 자바 기반의 설정 특히 애노테이션 기반의 컨트롤러를 사용할 때 편리하도록 스프링이 @EnableWebMvc 라는 애노테이션을 지원한다.

@EnableWebMvc 은 @Configuration 이 붙어있는 클래스에 같이 붙여주면 빈 설정을 더 간편하게 할 수 있는 메서드들을 제공한다.

@EnableWebMvc 를 사용하는 단계에선 아래처럼 사용한다.


### WebConfig.class
```java
@Configuration
@ComponentScan
// @EnableWebMvc 를 사용하는 단계.
@EnableWebMvc
public class WebConfig {

    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/");
        viewResolver.setSuffix(".jsp");
        return viewResolver;
    }
}
```

### WebApplication.class
```java
public class WebApplication implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        // setServletContext(...) 이 설정을 해 줘야 @EnableWebMvc 가 불러오는 servletContext 를 참조할 수 있게 되어 
        // 제대로 빈 설정이 된다.
        context.setServletContext(servletContext);
        context.register(WebConfig.class);
        context.refresh();

        DispatcherServlet dispatcherServlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic app = servletContext.addServlet("app", dispatcherServlet);
        app.addMapping("/app/*");
    }
}
```

디버깅을 통해 알 수 있는 점은 애노테이션 관련 HandlerAdapter 가 우선 순위가 높다는 점이다. 그래서 애노테이션 기반의 mvc 를 사용한다면 @EnableWebMvc 사용시 성능에 있어 더 유리할 수 있다.

@EnableWebMvc 는 delegation 하는 방식으로 작동한다. 따라서 손쉽게 기존의 빈에 interceptor 나 messageConverter 를 추가한다거나 하는게 가능해진다.

---

## 16.WebMvcConfigurer 인터페이스

@EnableWebMvc가 제공하는 빈을 커스터마이징 할 수 있는 기능을 제공하는 인터페이스

@EnableWebMvc 애노테이션을 사용할 때 등록되는 기본적인 빈들(DispatcherServlet이 아니라 import 하는 설정)이 delegation 구조로 되어있어 확장성에서 혜택을 주고 있다. 

그래서 __원하는 대로 커스터마이징 할 수 있도록 확장 지점을 인터페이스 형태로 지원하고 있다. 그 인터페이스가 바로 WebMvcConfigurer__ 이다.

WebMvcConfigurer 인터페이스는 스프링 부트를 사용하더라도 자주 사용되는 확장 지점중 하나다. 그래서 잘 알아두는게 좋다.

### WebConfig.class
```java
@Configuration
@ComponentScan
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    //    이렇게 WebMvcConfigurer 를 구현하면 아래처럼 viewResolver 를 빈으로 등록하며 설정해 주지 않아도
    //    손쉽게 커스터마이징이 가능하며 같은 효과를 낼 수 있다.
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.jsp("/WEB-INF/", ".jsp");
    }
    
//    @Bean
//    public ViewResolver viewResolver() {
//        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
//        viewResolver.setPrefix("/WEB-INF/");
//        viewResolver.setSuffix(".jsp");
//        return viewResolver;
//    }
}
```

### WebApplication.class
```java
public class WebApplication implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
        // setServletContext(...) 이 설정을 해 줘야 @EnableWebMvc 가 불러오는 servletContext 를 참조할 수 있게 되어
        // 제대로 빈 설정이 된다.
        context.setServletContext(servletContext);
        context.register(WebConfig.class);
        context.refresh();

        //    이 모양이 스프링 부트 없이 스프링 mvc 를 사용하는 방법이다.
        //    web.xml 없이 DispatcherServlet 을 아래처럼 코드로 등록해 주고(선택 사항), 
        //    그 DispatcherServlet 의 애플리케이션 컨텍스트를 위 과정에서 처럼 서블릿 컨텍스트로 셋팅하여 쓴다.
        DispatcherServlet dispatcherServlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic app = servletContext.addServlet("app", dispatcherServlet);
        app.addMapping("/app/*");
    }
}
```

---

## 17. 스프링 부트의 스프링 MVC 설정

<img width="369" alt="17" src="https://user-images.githubusercontent.com/35681772/63232980-c429bb00-c267-11e9-85c3-73bfeeebd492.png">



### 스프링 부트의 “주관”이 적용된 자동 설정이 동작한다.
 * JSP 보다 Thymeleaf 선호
 * JSON 지원
 * 정적 리소스 지원 (+ 웰컴 페이지, 파비콘 등 지원)

### 스프링 MVC 커스터마이징
 * application.properties : 가장 많이 손을 대지 않고 커스터마이징 할 수 있는 방법.

 * __@Configuration + Implements WebMvcConfigurer: 스프링 부트의 스프링 MVC 자동설정 + 추가 설정.__ 스프링 웹 MVC 가 지원하는 모든 설정을 사용하면서 추가로 커스터마이징 할 때 implements WebMvcConfigurer 가 필요하다. WebMvcConfigurer는 스프링 웹 MVC 가 제공.

 * @Configuration + @EnableWebMvc (+ Imlements WebMvcConfigurer): 스프링 부트의 스프링 MVC 자동 설정 사용하지 않음. 그런데 직접 설정을 하는 경우 WebMvcConfigurer 를 구현해야 하기 때문에 대부분의 경우 implements WebMvcConfigurer 가 포함된다.


__스프링 부트를 사용할 경우 Formatter는__ WebMvcConfiguration 내부에서 addFormatters() 메서드가 'Converter.class', 'GenericCOnverter.class', 'Formatter.class' 이 세 가지에 대해서는 __빈으로 등록만 되면 알아서 넣어주기 때문에 굳이 Formatter 를 등록하려고 오버라이드 할 필요가 없다.__

---

## 18.스프링부트에서 JSP 사용하기

> “​If possible, JSPs should be avoided. There are several ​known limitations​ when usingthem with embedded servlet containers.”

 * https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-template-engines

### 제약사항
 * JAR 프로젝트로 만들 수 없음, WAR 프로젝트로 만들어야함
 * Java -JAR로 실행 할 수는 있지만 “실행 가능한 JAR 파일”은 지원하지 않음
 * 언더토우(JBoss에서 만든 서블릿 컨테이너)는 JSP를 지원하지 않음
 * Whitelabel 에러 페이지를 error.jsp로 오버라이딩 할 수 없음.
 
### 참고
 * https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-jsp-limitations
 * https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp​ (샘플프로젝트)
 


### 의존성 추가
```xml
<!-- jsp를 쓰기 위해 필요한 의존성 두개.-->
<!-- jstl 을 사용할 떄 필요한 의존성 이다.-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>jstl</artifactId>
</dependency>
<!-- jsp 를 사용할 때 필요한 의존성-->
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <scope>provided</scope>
</dependency>
```
 
### Event.class
```java
public class Event {
    private String name;
    private LocalDateTime starts;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public LocalDateTime getStarts() {
        return starts;
    }

    public void setStarts(LocalDateTime starts) {
        this.starts = starts;
    }
}
```

### EventController.class
```java
@Controller
public class EventController {

    @GetMapping("/events")
    public String getEvnets(Model model) {
        Event event1 = new Event();
        event1.setName("스프링 웹 MVC 스터디 1");
        event1.setStarts(LocalDateTime.of(2019, 8, 11, 10, 0));
        Event event2 = new Event();
        event2.setName("스프링 웹 MVC 스터디 2");
        event2.setStarts(LocalDateTime.of(2019, 8, 12, 10, 0));

        List<Event> events = List.of(event1, event2);

        model.addAttribute("events", events);
        model.addAttribute("message", "welcome!!!");
        return "events/list";
    }
}
```

### ServletInitializer.class
```java
// WAR 로 패키지를 만들면 Initializer 가 하나 더 추가되게 된다.
// WAR 파일이기 때문에 톰캣에 배포해서 실행할 수 있다. 스프링 부트에 최적화 되어있는 Initializer.
public class ServletInitializer extends SpringBootServletInitializer {

//    톰캣이나 다른 서블릿 엔진에 배포할 경우 이 파일을 사용하게 되는 것
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(DemoJspApplication.class);
    }
}
```

### DemoJspApplication.class 
```java
@SpringBootApplication
public class DemoJspApplication {

//    독립적인 WAR 파일로 실행을 할 땐 이 클래스로 실행을 하게 되는 것
    public static void main(String[] args) {
        SpringApplication.run(DemoJspApplication.class, args);
    }
}
```


### 태그선언

### src > main > webapp > WEB-INF > jsp > events > list.jsp
```html
<%--    아래처럼 c 라이브러리에 대한 태그를 추가해준다.--%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>이벤트 목록</h1>
<%--    이런 표현식으로 모델에 담아뒀던 객체를 참조할 수 있다.--%>
    <h2>${message}</h2>
    <table>
        <tr>
            <th>이름</th>
            <th>시작</th>
        </tr>
        <c:forEach items="${events}" var="event">
            <tr>
                <td>${event.name}</td>
                <td>${event.starts}</td>
            </tr>
        </c:forEach>
    </table>
</body>
</html>
```
 
### application.properties
```
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp
```

이렇게 만든 애플리케이션을 패키징을 해 본다. 이 프로젝트가 WAR 이기 때문에 WAR 파일이 생긴다.

> [INFO] Building war: /Users/waggs/Documents/Inf/Spring_Web_MVC/demo-jsp/target/demo-jsp-0.0.1-SNAPSHOT.war

따라서 아래와 같은 명령어로 이 war 파일을 실행할 수 있다.
> java -jar target/*.war

---

## 19.WAR 파일 배포하기

<img width="540" alt="19" src="https://user-images.githubusercontent.com/35681772/63238248-78374000-c280-11e9-8530-66ae2128e1ca.png">


---


## 20.포매터 추가하기

우선 간단한 컨트롤러와 그 테스트를 작성해 본다. 컨트롤러를 먼저 작성한 뒤 cmd + shift + t 를 눌러 테스트 자동완성 기능을 사용할 수 있다.

### SampleController.class 
```java
@RestController
public class SampleController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```

### SampleControllerTest.class
```java
@RunWith(SpringRunner.class)
// 이 @WebMvcTest 애노테이션을 사용하면 MockMvc 라는 클래스를 자동으로 주입받을 수 있다.
@WebMvcTest
public class SampleControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        // "hello" 라는 요청을 보내면 본문(content)에 "hello" 라는 문자열이 나타날 것이다(andExpect)
        this.mockMvc.perform(get("/hello"))
                // 요청과 응답을 출력해 볼 수 있다.
                .andDo(print())
                .andExpect(content().string("hello"));
    }
}
```

테스트를 돌려보면 잘 통과하는것을 확인할 수 있다.

그런데 만약 get 요청으로 '/hello/waggs' 라는 요청을 받게 되면 본문 body 내용으로 'hello waggs' 라는 내용이 찍히게 하고싶다면?

### SampleControllerTest.class
```java
@RunWith(SpringRunner.class)
// 이 @WebMvcTest 애노테이션을 사용하면 MockMvc 라는 클래스를 자동으로 주입받을 수 있다.
@WebMvcTest
public class SampleControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        // "hello" 라는 요청을 보내면 본문(content)에 "hello" 라는 문자열이 나타날 것이다(andExpect)
        this.mockMvc.perform(get("/hello/waggs"))
                // 요청과 응답을 출력해 볼 수 있다.
                .andDo(print())
                .andExpect(content().string("hello waggs"));
    }
}
```

### SampleController.class
```java
@RestController
public class SampleController {

    // 아래처럼 url 로 부터 값을 가져오는 것을 'url path'로 받는다 라고 한다.
    @GetMapping("/hello/{name}")
    // 그래서 @PathVariable 이라는 애노테이션을 사용해서 url path의 값을 받아올 수 있다.
    public String hello(@PathVariable String name) {
        return "hello " + name;
    }
}
```

위와 같이 @PathVariable 을 사용해서 값을 받아올 수 있다.

그런데 __스프링 프레임웤 코어에 'Formatter'__ 라는 것이 있다.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#addFormatters-org.springframework.format.FormatterRegistry-

### Formatter 란?
 * Printer: 해당 객체를 (Locale 정보를 참고하여)​ 문자열​로 어떻게 출력할 것인가
 * Parser: 어떤​ 문자열​을 (Locale 정보를 참고하여) 객체로 어떻게 변환할 것인가

즉, __어떤 객체를 문자열로 변환__ 하거나 __문자열을 다른 객체로 변환__ 할 때 사용할 수 있는 인터페이스 이다.

그래서 __Formatter 를 사용하면 원하는 데이터를 객체로 받을 수 있다.__

### SampleController.class 
```java
@RestController
public class SampleController {

    // 아래처럼 url 로 부터 값을 가져오는 것을 'url path'로 받는다 라고 한다.
    @GetMapping("/hello/{name}")
    // 그래서 @PathVariable 이라는 애노테이션을 사용해서 url path의 값을 받아올 수 있다.
    public String hello(@PathVariable("name") Person person) {
        return "hello " + person.getName();
    }
}
```

이런식으로 받아서 쓰고싶다는 것이다. 

### Person.class
```java
public class Person {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

그래서 당장 이렇게만 만들고 테스트를 다시 돌려보면 실패하게 된다. "name" 으로 들어오는 값을 Person 객체로 변환해줄 수 없기 떄문.

이 "name" 으로 들어오는 데이터를 Person 객체로 변환하는 방법을 스프링이 모르기 때문이다. 따라서 그런 역할을 해 주는 Formatter 를 만든다.

### PersonFormatter.class 
```java
// 구현된 것을 확인해 보면 나오지만, Formatter 는 Printer 와 Parser 이 두 개의 인터페이스를 합쳐놓은 것이다.
// Printer는 객체를 문자열로 어떻게 변환할 것인가
// Parser는 문자열을 객체로 어떻게 변환할 것인가
public class PersonFormatter implements Formatter<Person> {

    @Override
    public Person parse(String s, Locale locale) throws ParseException {
        Person person = new Person();
        person.setName(s);
        return person;
    }

    @Override
    public String print(Person person, Locale locale) {
        return person.toString();
    }
}
```

그리고 이렇게 만든 포매터를 등록하는 방법은 아래처럼 두 가지가 있다.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/format/Formatter.html

### 포매터 추가하는 방법 1 (기존 스프링 Mvc 가 제공하는 방법)
 * WebMvcConfigurer의 addFormatters(FormatterRegistry) 메소드 정의 

### WebConfig.class 
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addFormatter(new PersonFormatter());
//        이 registry 에는 포매터 뿐 만 아니라 컨버터도 아래와 같이 등록해 줄 수 있다.
//        컨버터는 포매터보다 좀 더 general 한 용도로 사용된다. 
//        문자열 로 한정된 대상이 아니라, 일반 자바 객체에서 또 다른 자바 객체로의 변환을 가능하게 해 주는 인터페이스다.
//        registry.addConverter();
    }
}
```

이렇게 포매터를 웹 설정에 추가해주면 이제는 스프링 mvc 가 문자열을 Person 이라는 객체로 어떻게 변환해야 하는지 알 수 있게 된다.

그래서 테스트를 작동시키면 잘 동작하는 것을 확인할 수 있다.

그리고 이 포매터는 url path 뿐 아니라 request param 으로도 동작한다. 

request param 이라 함은 ```localhost:8080/hello?name=waggs``` 와 같이 주는것을 말한다.

### SampleController.class 
```java
@RestController
public class SampleController {

    @GetMapping("/hello")
    public String hello(@RequestParam("name") Person person) {
        return "hello " + person.getName();
    }
}
```

### SampleControllerTest.class 
```java
@RunWith(SpringRunner.class)
@WebMvcTest
public class SampleControllerTest {

    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        this.mockMvc.perform(get("/hello")
                // 이렇게 param 이라는 메서드를 사용해서 request param 을 받아올 수 있다.
                .param("name","waggs"))
                .andDo(print())
                .andExpect(content().string("hello waggs"));
    }
}
```

테스트가 잘 돌아가는것을 확인할 수 있다.

### 포매터 추가하는 방법 2 (스프링 부트 사용시에만 가능)
 * 해당 포매터를 빈으로 등록

 근데 __스프링 부트를 쓸 땐 위에서 사용한 WebConfig 설정이 없어도 된다.__

 스프링 부트가 자동으로 Formatter 가 빈으로 등록된 경우 스캔해서 연결해 준다.

 WebConfig 파일을 제거 한 뒤 만든 PersonFormatter 위에 @Component 애노테이션을 붙여 빈으로 등록만 해주고 실행해 본다.

### PersonFormatter.class 
 ```java
@Component
public class PersonFormatter implements Formatter<Person> {

    @Override
    public Person parse(String s, Locale locale) throws ParseException {
        Person person = new Person();
        person.setName(s);
        return person;
    }

    @Override
    public String print(Person person, Locale locale) {
        return person.toString();
    }
}
 ```

애플리케이션을 실행해서 직접 url 로 넣어보면 잘 동작하는데, __테스트는 깨지게 된다.__

그 이유는 테스트 코드에서 사용한 __@WebMvcTest 애노테이션은 슬라이싱 테스트 용이기 때문에 웹과 관련된 빈들만 등록해 준다.__

위에서 Formatter 를 @Component 애노테이션을 사용해서 빈으로 등록해 줬기 때문에 이는 더이상 웹과 관련된 빈이 아닌게 된다. @Controller 와 같은 애노테이션이 아니기 때문에.

따라서 테스트 코드에서 __@SpringBootTest 라는 애노테이션을 써서 통합 테스트로 모든 빈들을 다 등록시키는 방법을 사용하면 된다.__

### SampleControllerTest.class 
```java
@RunWith(SpringRunner.class)
// @SpringBootTest 를 사용하면 mockMvc 가 자동으로 빈으로 등록되지 않는다.
// 따라서 @AutoConfigureMockMvc 를 사용해 줘야 한다.
@SpringBootTest
@AutoConfigureMockMvc
public class SampleControllerTest {
    @Autowired
    MockMvc mockMvc;

    @Test
    public void hello() throws Exception {
        this.mockMvc.perform(get("/hello")
                // 이렇게 param 이라는 메서드를 사용해서 request param 을 받아올 수 있다.
                .param("name","waggs"))
                .andDo(print())
                .andExpect(content().string("hello waggs"));
    }
}
```

---

## 21.도메인 클래스 컨버터 자동 등록

### SampleController.class 
```java
@RestController
public class SampleController {

    @GetMapping("/hello")
    public String hello(@RequestParam("id") Person person) {
        return "hello " + person.getName();
    }
}
```
많은 경우에 있어 __@RequestParam 으로 id 값을 받아서 이 값으로 어떤 객체를 불러와서 그 객체의 이름을 출력(person.getName())__ 하는 식의 시나리오가 전개된다.

하지만 이런 경우엔 포매터를 사용하지 않고(사용해도 되지만) __스프링 데이터 JPA__ 의 도움을 받으면 된다.

스프링 데이터 JPA는 스프링 MVC용 도메인 클래스 컨버터를 제공합니다.

### 도메인 클래스 컨버터
 * 스프링 데이터 JPA가 제공하는 Repository를 사용해서 ID에 해당하는 엔티티를 읽어옵니다.
 * 어떤 id 에 해당하는 도메인 클래스로 변환을 해 준다.

### 의존성 설정
### pom.xml
```xml
<!--spring-boot-data-jpa 를 추가하고-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<!--이 스프링 부트 데이터 JPA 가 사용할 데이터베이스로 h2를 사용하겠다-->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
</dependency>
```

### 엔티티 맵핑
### Person.class
```java
@Entity
public class Person {
//    @GeneratedValue는 해당 id 가 데이터베이스에 들어갈 때 자동 생성되도록 지정해 주는 것.
    @Id @GeneratedValue
    private Long id;
    
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

### 리파지토리 추가
### PersonRepository.interface 
```java
// id 값에서 어떤 Entity 로 컨버팅 할 때, 리파지토리를 사용하기 때문에 있어야 한다.
// JpaRepository를 만드는 방법은 아래처럼 인터페이스를 만들고 JpaRepository 를 상속받으며
// 제네릭 타입으로 첫번째 타입으로 Entity 타입, 두번째 타입으로 key 값의 타입인 Long을 주면 된다.
public interface PersonRepository extends JpaRepository<Person, Long> {
}
```

### 테스트 코드 수정
 * 테스트용 이벤트 객체 생성
 * 이벤트 리파지토리에 저장
 * 저장한 이벤트의 ID로 조회 시도

### SampleControllerTest.class 
```java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class SampleControllerTest {
    @Autowired
    MockMvc mockMvc;

    @Autowired
    PersonRepository personRepository;

    @Test
    public void hello() throws Exception {
        // 객체를 생성해서 저장하기 위해 생성하는 과정.
        // Id 값은 자동 저장되게 애노테이션으로 설정해 두었기 때문에 이름만 설정해준다.
        Person person = new Person();
        person.setName("waggs");

        // Repository 에 save 하면 그 save 한 객체를 돌려준다. 그래서 걔를 받아와서
        Person savedPerson = personRepository.save(person);

        this.mockMvc.perform(get("/hello")
                // param 으로 그 객체의 id 를 가져오는 것이다.
                .param("id", savedPerson.getId().toString()))
                .andDo(print())
                // id 에 해당하는 person 객체의 이름이 출력되면 된다.
                .andExpect(content().string("hello waggs"));
    }
}
```

Test 에서 저장한 Person 객체가 SampleController 상에서 type conversion 을 할 때, id에 해당하는 person 객체를 찾아 이름을 찍어주는 것이다.

이렇게 __도메인 클래스 같은 경우 컨버터를 스프링 데이터 jpa 가 자동으로 등록__ 해 주기 때문에, 도메인 전용으로 따로 커스텀하게 만들 일은 자주 발생하지 않는다.

---

## 22.핸들러 인터셉터 1부: 개념

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#addInterceptors-org.springframework.web.servlet.config.annotation.InterceptorRegistry-

### HandlerInterceptor

 * __핸들러 맵핑(어떠한 요청을 처리할 핸들러를 찾아주는 역할)__ 에 설정할 수 있는 인터셉터
 * 핸들러를 실행하기 전, 후(아직 랜더링 전) 그리고 완료(랜더링까지 끝난 이후) 시점에 부가 작업을 하고 싶은 경우에 사용할 수 있다.
 * 여러 핸들러에서 반복적으로 사용하는 코드를 줄이고 싶을 때 사용할 수 있다.
   * 로깅, 인증체크, Locale 변경 등...

__preHandle__ -> (preHandle 에서 true를 리턴했다면) 요청 처리 -> __postHandle__ -> 뷰 랜더링 -> __afterCompletion__

이렇게 3 단계에 해당하는 전, 후 처리를 해줄 수 있다.

### boolean preHandle(request, response, ​__handler​__)
 * 핸들러 실행하기 전에 호출 됨
 * “핸들러"에 대한 정보를 사용할 수 있기 때문에 서블릿 필터에 비해 보다 세밀한 로직을 구현할 수 있다.
 * 리턴값으로 계속 다음 인터셉터 또는 핸들러로 요청,응답을 전달할지(true) 응답 처리가 이곳에서 끝났는지(false) 알린다.

### void postHandle(request, response, ​modelAndView​)
 * 핸들러 실행이 끝나고 아직 뷰를 랜더링 하기 이전에 호출 됨
 * “뷰"에 전달할 추가적이거나 여러 핸들러에 공통적인 모델 정보를 담는데 사용할 수도 있다.
 * 이 메소드는 인터셉터 역순으로 호출된다.
 * 비동기적인 요청 처리 시에는 호출되지 않는다.
 * ModelAndView 를 제공하기 때문에 이를 커스터마이징 할 수 있다. 모델에 추가적인 정보를 넣는다거나, 뷰를 변경한다거나 하는 일들이 가능하다.

### void afterCompletion(request, response, handler, ex)
 * 요청 처리가 완전히 끝난 뒤(뷰 랜더링 끝난 뒤)에 호출 됨
 * preHandler에서 true를 리턴한 경우에만 호출 됨
 * 이 메소드는 인터셉터 역순으로 호출된다.
 * 비동기적인 요청 처리 시에는 호출되지 않는다.

### '역순' 을 반영한 호출 순서

preHandle 1 -> preHandle 2 -> 요청 처리 -> postHandle 2 -> postHandle 1 -> 뷰 렌더링 -> afterCompletion 2 -> afterCompletion 1

### vs 서블릿 필터
 * 서블릿 보다 구체적인 처리가 가능하다.
 * 서블릿은 보다 일반적인 용도의 기능을 구현하는데 사용하는게 좋다.

general 한 용도의 경우 서블릿 필터로 구현, 스프링 mvc 에 특화되어 있는 로직을 구현해야 할 경우 핸들러 인터셉터로 구현한다.

가령 XSS(Cross-site Scripting) attack 에 관련된 경우 '스프링 mvc 와는 아무런 관련이 없으므로' 서블릿 필터로 구현을 해야한다. (네이버의 lusy-xss-filter)

### 참고
 * https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerInterceptor.html

 * https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html

 * http://forum.spring.io/forum/spring-projects/web/20146-what-is-the-difference-between-using-a-filter-and-interceptor​ (스프링 개발자 Mark Fisher의 서블릿 필터와의 차이점에 대한 답변 참고)

---

## 23.핸들러 인터셉터 2부: 만들고 등록하기

### 핸들러 인터셉터 구현하기
### GreetingInterceptor.class 
```java
public class GreetingInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle 1");
        // return 을 true 로 해서 다음 핸들러까지 요청 처리를 할 수 있도록 보낸다.
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle 1");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion 1");
    }
}
```

### AnotherInterceptor.class 
```java
public class AnotherInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle 2");
        // return 을 true 로 해서 다음 핸들러까지 요청 처리를 할 수 있도록 보낸다.
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle 2");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion 2");
    }
}
```

이렇게 인터셉터 2개를 만들고 WebConfig 에 등록한다.

### 핸들러 인터셉터 등록하기
### WebConfig.class 
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new GreetingInterceptor());
        registry.addInterceptor(new AnotherInterceptor());
    }
}
```

이렇게 등록한 다음 출력을 해 보면 다음과 같은 순서(역순) 으로 출력이 되는것을 확인할 수 있다.

```
preHandle 1
preHandle 2
postHandle 2
postHandle 1
afterCompletion 2
afterCompletion 1
```

### WebConfig.class 
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
//        이렇게 order 를 줄 수 있다. order 값은 낮을수록 우선 순위가 높다.
        registry.addInterceptor(new GreetingInterceptor()).order(0);
        registry.addInterceptor(new AnotherInterceptor()).order(-1);
    }
}
```

위와 같이 우선 순위를 부여한 결과 아래와 같은 순서가 된다.
```
preHandle 2
preHandle 1
postHandle 1
postHandle 2
afterCompletion 1
afterCompletion 2
```

 * 특정 패턴에 해당하는 요청에만 적용할 수도 있다.
 * 순서를 지정할 수 있다.

### WebConfig.class 
 ```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new GreetingInterceptor()).order(0);
        registry.addInterceptor(new AnotherInterceptor())
                .addPathPatterns("/hi")         // 특정 url path 패턴에만 적용하고 싶은 경우.
                .order(-1);                     // 이렇게 되면 hi 로 테스트를 하지 않는다면
                                                // AnotherInterceptor() 는 호출이 되지 않게 된다.
    }
}
 ```

---

## 24.리소스 핸들러

__리소스 핸들러 : 이미지, 자바스크립트, CSS 그리고 HTML 파일과 같은 정적인 리소스의 요청을 처리하는 핸들러__

이 리소스 핸들러는 서블릿 컨테이너(톰캣 등..)가 기본으로 제공하는 디폴트 서블릿이 이미 존재한다.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#addResourceHandlers-org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry-

### 디폴트(Default) 서블릿
 * 서블릿 컨테이너가 기본으로 제공하는 서블릿으로 정적인 리소스를 처리할 때 사용한다.
 * https://tomcat.apache.org/tomcat-9.0-doc/default-servlet.html
 * 스프링은 이렇게 이미 등록되어 있는 디폴트 서블릿에 해당 요청들을 '위임'해서 정적인 리소스를 처리하게 된다.

그런데 직접 정의한 핸들러보다 이 정적 리소스 핸들러들이 먼저 요청에 대한 처리를 가로채면 직접 정의한 핸들러가 작동하지 않아 무의미해진다. 그래서 정적 리소스 핸들러들은 우선 순위가 낮게 된다.

### 스프링 MVC 리소스 핸들러 맵핑 등록
 * 가장 낮은 우선 순위로 등록.
   * 다른 핸들러 맵핑이 “/” 이하 요청을 처리하도록 허용하고
   * 최종적으로 리소스 핸들러가 처리하도록.
 * DefaultServletHandlerConfigurer
 
정적 리소스 핸들러를 등록하는 방법은 스프링 부트에서는 아무런 설정을 해 주지 않아도 특정 디렉토리에 담아두기만 하면 등록을 해 준다. 그 디렉토리중 하나가 resources > static 이다.

### resources > static > index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>hello index</h1>
</body>
</html>
```

### SampleControllerTest.class
```java
@Test
public void helloStatic() throws Exception {
    this.mockMvc.perform(get("/index.html"))
            .andDo(print())
            .andExpect(status().isOk())
            .andExpect(content().string(Matchers.containsString("hello index")));
}
```

이렇게 테스트를 해 보면 잘 통과하게 된다.

 ### 리소스 핸들러 설정
 * 어떤 요청 패턴을 지원할 것인가
 * 어디서 리소스를 찾을 것인가
 * 캐싱
 * ResourceResolver: 요청에 해당하는 리소스를 찾는 전략
   * 캐싱, 인코딩(gzip, brotli), WebJar, ...
 * ResourceTransformer: 응답으로 보낼 리소스를 수정하는 전략
   * 캐싱, CSS 링크, HTML5 AppCache, ...

근데 위와 같이 스프링 부트가 기본적으로 제공하는 리소스 핸들러 말고 직접 커스터마이징 해서 사용하고 싶은 경우 이렇게 하면 된다.

### WebConfig.class
```java
 // 리소스 핸들러를 직접 커스터마이징 하는 방법.
 @Override
 public void addResourceHandlers(ResourceHandlerRegistry registry) {
             // 어떠한 패턴의 요청을 처리할지
     registry.addResourceHandler("/mobile/**")
             // 이 리소스를 어디서 찾아야 하는지
             // classpath 의 루트는 src > main 아래 java 와 resources 이다.
             // 그래서 resources 밑에 mobile 이라는 디렉토리를 만들고
             // 그 mobile 이라는 디렉토리 아래에 위치하는 요청이 들어오면 특정 페이지가
             // 보여지게 된다.
             .addResourceLocations("classpath:/mobile/")
             // 이렇게 캐시 컨트롤을 추가해주면, 이 리소스 핸들러에서 처리하는 응답엔
             // 캐시와 관련된 전략이 추가가 되고, 이 응답은 리소스에 변경이 있지 않다면 10분동안 캐싱을 하게 된다.
             // 만약 리소스에 변경이 있다면 10분이 지나지 않아도 다시 리소스를 받아오게 된다.
             .setCacheControl(CacheControl.maxAge(10, TimeUnit.MINUTES));

 }
```

### SampleControllerTest.class
```java
@Test
public void helloStatic() throws Exception {
    this.mockMvc.perform(get("/mobile/index.html"))
            .andDo(print())
            .andExpect(status().isOk())
            .andExpect(content().string(Matchers.containsString("Hello Mobile")))
            .andExpect(header().exists(HttpHeaders.CACHE_CONTROL)); // 헤더에 관련 내용이 들어있는지 확인하기 위해.
}
```

위와 같이 테스트 해볼 수 있다.

### 스프링 부트
 * 기본 정적 리소스 핸들러와 캐싱 제공
 * 그 캐싱 기능은 application.properties 에서 제어할 수 있다.

### 참고
 * https://www.slideshare.net/rstoya05/resource-handling-spring-framework-41

---

## 25.HTTP 메시지 컨버터 1부: 개요

HTTP 메시지 컨버터 역시 WebMvcConfigurer 로 설정할 수 있다.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-

### HTTP 메시지 컨버터
 * 요청 본문에서 메시지를 읽어들이거나(@RequestBody), 응답 본문에 메시지를 작성할 때(@ResponseBody) 사용한다.

### SampleController.class 
```java
@RestController
public class SampleController {

    // preHandler
    // 요청 처리
    // postHandler
    // 뷰 랜더링
    // afterCompletion

    @GetMapping("/hello")
    public String hello(@RequestParam("id") Person person) {
        return "hello " + person.getName();
    }
    
    @GetMapping("/message")
    // @ResponseBody 애노테이션이 붙어있는 경우엔 이 메서드에서 리턴하는 값을 응답의 본문으로 넣어주게 된다.
    // 그런데 우리는 @RestController 라는 애노테이션을 사용하고 있기 때문에 모든 핸들러 메서드에 @ResponseBody 가 있는거나 마찬가지이다.
    @ResponseBody
    public String message(@RequestBody Person person) { // @RequestBody 라는 애노테이션을 사용하면 
        return "hello " + person.getName();             // 요청 본문에 들어있는 메세지를 HTTP 메세지 컨버터를 사용하여 conversion 을 한다.
    }
}
```

이렇게 HTTP 메시지 컨버터는 @RequestBody 와 @ResponseBody 를 사용할 때 적용이 된다. 어떤 요청 본문에 들어있는 문자열을 변환하거나 객체로 변환하는 등의 작업이 가능하다.

### 기본 HTTP 메시지 컨버터
 * 바이트 배열 컨버터
 * 문자열 컨버터
 * Resource 컨버터
 * Form 컨버터 (폼 데이터 to/from MultiValueMap<String, String>)
 * (JAXB2 컨버터)
 * (Jackson2 컨버터)
 * (Jackson 컨버터)
 * (Gson 컨버터)
 * (Atom 컨버터)
 * (RSS 컨버터)
 * ...

괄호가 쳐 진 경우 pom.xml 에 해당 타입의 dependency 가 있는 경우에만 등록이 된다.

### SampleController.class 
```java
    @GetMapping("/message")
    @ResponseBody
    public String message(@RequestBody String body) { 
        return body;                                  
    }
```

### 설정 방법
 * 기본으로 등록해주는 컨버터에 새로운 컨버터 추가하기 : extendMessageConverters
 * 기본으로 등록해주는 컨버터는 다 무시하고 새로 컨버터 설정하기 : configureMessageConverters
 * __의존성 추가로 컨버터 등록하기 (추천)__
   * __메이븐 또는 그래들 설정에 의존성을 추가하면 그에 따른 컨버터가 자동으로 등록된다.__
   * __WebMvcConfigurationSupport__
   * (이 기능 자체는 스프링 프레임워크의기능임, 스프링부트 아님.)

### WebConfig.class
```java
//                만약 아무것도 등록하지 않으면 기본 컨버터 들을 사용하게 된다.
//                그런데 추가 하면 '기본 컨버터들이 사용되지 않는다'.
@Override
public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
//                따라서 이 메세지를 구현하면 기본 컨버터들이 등록되지 않는 상황을 방지할 수 있다.
}
```

그런데 위 방법보다도 __의존성을 추가하여 컨버터를 등록하는 방법을 훨씬 자주 쓰게 된다.__

### 참고
 * https://www.baeldung.com/spring-httpmessageconverter-rest

---
