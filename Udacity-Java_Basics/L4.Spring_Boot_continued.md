# L4.Spring_Boot_continued

## 1. Spring Boot Exception

### Spring Boot Exception Handling

Similar to Java, Spring boot has his own exceptions. 

There are five types of situations we can handle Spring Boot exceptions rather than showing error pages like 404 or 500.

1. Create custom error page.

2. @ExceptionHandler.

3. @ControllerAdvice + @ExceptionHandler.

4. Configure SimpleMappingExceptionResolver class.

5. Custom HandlerExceptionResolver class.


### project : spring-boot-exception

### controller > UserController.class
```java
@Controller
public class UserController {
    @RequestMapping("/add")
    public String add() {
        int num = 10 / 0;
        return "add";
    }
}
```

### resources > templates > add.html
```html
empty or default (doesn't matter)
```

The result is the 'spring boot default error handling page'. 

```
There was an unexpected error (type=Internal Server Error, status=500).
/ by zero
java.lang.ArithmeticException: / by zero
...
```

But what if we want to show our own custom page???

What we can do is to __add a error.html page in resources/template folder.__

### resources > templates > error.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Custom Error Page</title>
</head>
<body>
<h2>ERROR PAGE</h2>
</body>
</html>
```

Because we are using devTool already, once you add the error page, you can just refresh localhost:8080/add, and you should see the error.html page you just created, not the default Spring boot error page.

Create a custom error page is easy, but for most of the users, it’s not ideal because they want to separate error handling page for different errors. Let’s take a look at different solutions.

### Spring boot exception @exceptionhandler example prep

Adding a new method in the controller.

### UserController.class
```java
@ExceptionHandler(value = {ArithmeticException.class})
public ModelAndView handlerArithmeticException(Exception e) {
    ModelAndView mav = new ModelAndView();
    mav.addObject("exception", e.toString());
    mav.setViewName("mathError");
    return mav;
}
```

Rename error.html to error.bak.html

Add new html under template folder named mathError.html.

### resources > templates > mathError.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Math Error Page</title>
</head>
<body>
This contains math exceptions.
</body>
</html>
```

then you can see if there's ArithmeticException then it goes to our custom mathError page.

### Spring boot - ExceptionHandler example 2

This time we are going to handle a different exception, null pointer exception. Update the controller and add two methods.

### UserController.class
```java
@RequestMapping("/update")
public String update() {
    String name = null;
    name = name.toLowerCase();  // this should cause null pointer exception
    return name;
}

@ExceptionHandler(value = {NullPointerException.class})
    public ModelAndView handlerNullPointerException(Exception e) {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e.toString());
        mav.setViewName("nullPointerError");
        return mav;
    }
```

### ... > nullPointerError.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Null Pointer Error Page</title>
</head>
<body>
This contains null pointer exception.
</body>
</html>
```

---

## 2. Spring Boot Exception- @ControllerAdvise + @ExceptionHandler

만약 컨트롤러가 여러개라면? 매번 모든 예외들을 하나하나 다 처리해 줄 수는 없다. 그래서 모든 예외를 담당하는 global exception handler 를 만들어 사용한다.

기존 UserController 내부의 add 메소드를 RoleController 클래스를 새로 생성해 거기로 옮겨넣고, exceptions 폴더 아래 GlobalExceptionHandler 클래스를 만들어 기존 exception handler 메서드를 모아둔다.

### GlobalExceptionHandler.class
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(value = {ArithmeticException.class})
    public ModelAndView handlerArithmeticException(Exception e) {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e.toString());
        mav.setViewName("mathError");
        return mav;
    }
    @ExceptionHandler(value = {NullPointerException.class})
    public ModelAndView handlerNullPointerException(Exception e) {
        ModelAndView mav = new ModelAndView();
        mav.addObject("exception", e.toString());
        mav.setViewName("nullPointerError");
        return mav;
    }
}
```

---

## 3. Spring Boot Exception - SimpleMappingExceptionResolver

위에서 만들어 본 exception handler 는 꽤 괜찮지만, 모든 예외들을 직접 하나하나 정의하여 만들어 줘야 한다. 

그 대신 SimpleMappingExceptionResolver 를 사용하여 스프링 부트가 제공하는 mapping 기능을 이용해 본다.

하나의 메서드를 만들어 이 메서드가 모든 예외들을 handling 하도록 제공한다. 아래와 같이 key-value 쌍으로 특정 예외와 그 뷰 이름을 넣어준다.

Let’s make our GloablExceptionHandler as bak first, so that we can keep our code. Rename GloablExceptionHandler.java to GlobalExceptionHandler.java.bak Create a MySimpleMappingExceptionResolver class under exceptions directory.

```java
@Configuration
public class MySimpleMappingExceptionResolver {
   @Bean
   public SimpleMappingExceptionResolver getSimpleMappingExceptionResolver() {
       SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
       Properties mapping = new Properties();
       //key = exception full name. value = view name.
       mapping.put("java.lang.ArithmeticException", "mathError"); 
       mapping.put("java.lang.NullPointerException", "nullPointerError");
       resolver.setExceptionMappings(mapping);
       return resolver;
   }
}
```

다음으로 HandlerExceptionResolver 를 사용한 방법을 알아보자.

HandlerExceptionResolver 는 SimpleMappingExceptionResolver 와 매우 유사하지만, __리플렉션__ 을 사용하여 어떤 종류의 예외인지 파악하고, 그에 대응하는 뷰를 할당하여 예외를 처리한다.

### MyHandlerExceptionResolver.class 
```java
@Configuration
public class MyHandlerExceptionResolver implements HandlerExceptionResolver{
   @Override
   public ModelAndView resolveException(HttpServletRequest httpServletRequest,
                                        HttpServletResponse httpServletResponse, @Nullable Object o, Exception e) {
       ModelAndView mv = new ModelAndView();
       if (e instanceof ArithmeticException) {
           mv.setViewName("mathError");
       }
       if (e instanceof NullPointerException) {
           mv.setViewName("nullPointerError");
       }
       mv.addObject("exception", e.toString());
       return mv;
   }
}
```

## recap

1. Create custom error page. -> create a error.html page, when errors happen, customer will be redirected to this page.

2. @ExceptionHandler. -> handle exceptions inside each controller.

3. @ControllerAdvice + @ExceptionHandler Create a separate class and write all exceptions based on their types.

4. Configure SimpleMappingExceptionResolver class -> Rather than adding one method per exception, create a key-value pair class, and let system look for the error.

5. Custom HandlerExceptionResolver class -> use reflection to find what type of exception it’s

---

## 5. WebSocket

### Content
 * WebSocket Introduction
 * STOMP Introduction and STOMP commands
 * Spring Boot WebSocket Components
   * WebSocketConfig
   * Message
   * Message Wrapper
   * Message Controller
   * Browser Client
   * Scheduler

### What is WebSocket?

<img width="619" alt="websocket" src="https://user-images.githubusercontent.com/35681772/64086002-b77d8a80-cd70-11e9-904f-7c4a22f8bfe9.png">

Web Socket is a protocol used to transmit real-time messages between client and server.

Therefore, to implement a WebSocket application, we need to have both server side and client side.

### WebSocket and STOMP Protocols

Websocket is a low-level protocol. It defines how a stream of bytes is transformed into frames, which contains a text or binary message. A WebSocket message itself does not have instructions about how to route or process it. Therefore, we need additional support to achieve two-way communication. With Spring Boot, we have STOPM.

STOMP is a simple text-based message protocol. With it, clients can send and receive messages to and from each other. STOMP is called HTTP for Web. It defines a handful of frame types that are mapped onto WebSockets frames, e.g., CONNECT, SUBSCRIBE, UNSUBSCRIBE, ACK, or SEND.

### STOMP : Simple Text Oriented Message Protocol
#### STOMP Frame Object
 * Command -> String
 * Headers -> JavaScript Object
 * Body -> String

#### STOMP Commands
 * CONNECT
 * SEND
 * SUBSCRIBE
 * UNSUBSCRIBE
 * BEGIN
 * COMMIT
 * ABORT
 * ACK
 * NACK
 * DISCONNECT

#### Spring Boot WebSocket Components
   * WebSocketConfig : config to create WebSocket and add message broker information
   * Message : what we get from UI
   * Message Wrapper : to add some contents and push back to UI
   * Message Controller : receive message from UI


### project : spring-boot-websocket



---