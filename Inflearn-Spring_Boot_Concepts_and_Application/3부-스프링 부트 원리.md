# 3부: 스프링 부트 원리

3부에서는 스프링 부트의 핵심 원리를 학습합니다. 스프링 부트가 제공하는 ‘의존성 관리', ‘자동 설정' 그리고 ‘내장 서블릿 컨테이너'에 대해 학습합니다. 

---

## 7. 의존성 관리 이해

어떻게 단 몇 개의 의존성 설정만으로 수 많은 의존성들을 가져 왔는지 그리고 왜 이게 좋은지에 대해 알아본다.

```xml
<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
</dependencies>
```

처음 프로젝트를 생성한 후 넣어준 의존성은 두 개 뿐이다. 그리고 버전을 명시하지도 않았는데 알아서 적절한 버전의 의존성을 가져온다. 이는 스프링이 제공해 주는 '의존성 관리 기능' 때문.

어떻게 이렇게 가져올 수 있는가를 알아보면

'spring-boot-starter-parent' parent pom 으로 들어가서 올라가고 또 'spring-boot-dependencies' 로 타고 올라간다. 가장 위에 있는 애가 'spring-boot-dependencies' 가 된다. 

그러니깐 'spring-boot-dependencies' 아래 'spring-boot-starter-parent' 가 있는 것.

'spring-boot-dependencies' 엔 아래처럼 수 많은 버전들이 적혀 있다.

```xml
<activemq.version>5.15.9</activemq.version>
<antlr2.version>2.7.7</antlr2.version>
<appengine-sdk.version>1.9.75</appengine-sdk.version>
<artemis.version>2.6.4</artemis.version>
<aspectj.version>1.9.4</aspectj.version>
<assertj.version>3.11.1</assertj.version>
<atomikos.version>4.0.6</atomikos.version>
<bitronix.version>2.1.4</bitronix.version>
<build-helper-maven-plugin.version>3.0.0</build-helper-maven-plugin.version>
<byte-buddy.version>1.9.13</byte-buddy.version>
<caffeine.version>2.6.2</caffeine.version>
<cassandra-driver.version>3.6.0</cassandra-driver.version>
<classmate.version>1.4.0</classmate.version>
<commons-codec.version>1.11</commons-codec.version>
<commons-dbcp2.version>2.5.0</commons-dbcp2.version>
...
```

또한 'dependencyManagement' 도 정의되어 있다.

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot</artifactId>
      <version>2.1.6.RELEASE</version>
    </dependency>
    ...
```

그렇기 때문에 pom.xml 에서 'spring-boot-dependencies' 에 정의된 것 중에 하나라도 사용하게 되면 직접 버전을 명시하지 않아도 'spring-boot-dependencies' 에서 관리되는 버전을 쓰게 된다.

따라서 pom.xml 에 사용하겠다고 명시한 'spring-boot-starter-web' 에는 좌측 line 표시 옆에 작게 가져올 버전을 IntelliJ 를 통해 확인할 수도 있고 클릭해서 들어가면 확인이 가능하다. 어떤 버전의 spring web MVC 를 가져올 것인지는 'spring-boot-starter-web' 이 안에 정의가 되어있음.

<img width="713" alt="dependencies hierarcy" src="https://user-images.githubusercontent.com/35681772/62091759-83183980-b2ad-11e9-8d37-779bfd63bec5.png">

이렇게 인텔리제이 상에서도 hierarcy layer 를 확인이 가능하다. 

이렇게 의존성들이 정의되어 있기 때문에 최종적으로 수 많은 라이브러리들이 자동으로 들어오게 된 것이다.  

dependency management 를 해 주는 기능이 왜 좋으냐면
  * 직접 관리 해 줘야할 의존성의 수가 줄어든다 - 내가 해야 할 일이 줄어든다는 것.
  * pom 에서 지원하는 의존성은 버전을 명시하지 않아도 된다 - 지원하지 않는 의존성 같은 경우 버전을 명시해 줘야 함.
  * 스프링이 의존성을 관리하는 방법이 parent 를 사용하는 방법인데, parent pom을 쓰지 않고 다른 방법 사용도 가능.

만약 parent 로 받아서 사용하지 않고 dependency management 로 받아 사용하게 되면 parent 로 받아 사용할 때 받을 수 있는 의존성 및 기타 셋팅들의 수가 줄어들게 된다. 따라서 parent 로 받아 사용하는 것이 권장됨.


https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-dependency-management

---

## 8. 의존성 관리 응용

  * 버전 관리 해주는 의존성 추가
  * 버전 관리 안해주는 의존성 추가 
  * 기존 의존성 버전 변경하기 
  * https://mvnrepository.com/

의존성을 추가해 주는 방법에 대해 알아본다.

### 버전 관리 해주는 의존성 추가

먼저 spring data JPA 를 추가해 보자.

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```


<img width="589" alt="dependencies hierarcy - added spring-boot-starter-data-jpa" src="https://user-images.githubusercontent.com/35681772/62095404-510dd400-b2bb-11e9-8838-8991734b8b9f.png">

이렇게 의존성을 pom.xml에 추가해 주면 된다. 추가 해 주면 우측 maven dependencies hierarcy 에 'spring-boot-starter-data-jpa' 가 추가된 것을 확인할 수 있다.

### 버전 관리 안해주는 의존성 추가

이렇게 추가 할 수도 있고, 메이븐 의존성을 찾아서 검색 후 추가하고 싶을 땐 mvnrepository 에서 검색이 가능하다.

mvn repository 에서 'modelmapper' 라는 의존성을 추가해보면 아래 코드를 pom에 붙여넣으면 된다.

```xml
<dependency>
	<groupId>org.modelmapper</groupId>
	<artifactId>modelmapper</artifactId>
	<version>2.3.5</version>
</dependency>
```

이 경우 코드 라인 옆에 화살표 같은게 안뜬다. 그 이유는 스프링 부트가 관리해주는 의존성이 아니기 때문. 따라서 버전을 명시해 주는것이 좋다. 버전을 명시해 주는게 best practice 이다.

### 기존 의존성 버전 변경하기 

스프링의 버전을 바꿔본다. 

'spring-boot-dependencies' 에 

```xml
<spring.version>5.1.8.RELEASE</spring.version>
```

이렇게 스프링의 버전이 명시되어 있다. 

그리고 pom.xml 의 properties 아래에 다음과 같이 추가해 주면 된다.

```xml
<properties>
	<java.version>1.8</java.version>
	<spring.version>5.0.6.RELEASE</spring.version>
</properties>

```

그러면 우측 maven dependencies 에서 'org.springframework:spring-web:5.0.6.RELEASE' 로 변경된 것을 확인할 수 있다.

스프링 부트가 관리하는 의존성들은 이 처럼 변경할 수 있다.

---

## 9. 자동설정이해

프로젝트 초기 상태에서 App을 run 하면 콘솔에 많은 로그들이 찍히면서 톰캣도 뜨고 많은 일들이 일어난다. 이렇게 자동으로 일이 수행되는 이유에 대해 알아본다.

그 이유 중 하나가 @SpringBootApplication 안에 있는 @EnableAutoConfiguration 때문이다.

 * @EnableAutoConfiguration (@SpringBootApplication 안에 숨어 있음) 

그렇기 때문에 @SpringBootApplication 애노테이션은 아래와 같이 3개의 애노테이션으로 바꿔 동작하게 할 수 있다.

### Application.class
```java
//@SpringBootApplication
@SpringBootConfiguration
@ComponentScan
@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

스프링 부트 애플리케이션은 빈을 두 단계로 등록을 한다. 컴포넌트 스캔으로 빈을 먼저 읽어 들이고, 'EnableAutoConfiguration' 으로 읽어온 빈들을 다시 또 빈으로 등록을 한다.

 * 빈은 사실 두 단계로 나눠서 읽힘
   * 1단계: @ComponentScan
   * 2단계: @EnableAutoConfiguration 

따라서 아래와 같이 EnableAutoConfiguration 단계가 없어도 스프링 부트는 사용을 할 수 있다.

### Application.class
```java
//@SpringBootApplication
@SpringBootConfiguration
@ComponentScan
//@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(Application.class);
        application.setWebApplicationType(WebApplicationType.NONE);
        application.run(args);
    }
}
```

이렇게 커스터마이징 해서 웹 애플리케이션으로 만들지 않고 작동을 시킬 수 있다.

웹 애플리케이션으로 실행을 하려면 'ServletWebServerFactory' 타입의 빈이 있어야 한다. 이 빈은 '@EnableAutoConfiguration' 에서 자동으로 생성하여 빈으로 등록해 주는데 이걸 주석처리 하면 위의 빈이 없다고 에러가 난다.

그래서 스프링 어플리케이션을 커스터마이징 해서 웹 어플리케이션 타입이 아닌걸로 셋팅한 뒤 실행을 한 것이다.

이렇게 하면 '@EnableAutoConfiguration' 없이도 실행이 되는걸 볼 수 있는데, 물론 웹 서버로 동작하지는 않게 된다.

다시 말해서 '@EnableAutoConfiguration' 은 컴포넌트 스캔으로 빈을 읽어들인 이후에 추가적으로 빈들을 읽어들여서 등록을 해 준다.

 * @ComponentScan   // @Component 애노테이션을 가진 클래스들을 스캔해서 빈으로 등록하는 것.
   * @Component     
   * @Configuration @Repository @Service @Controller @RestController
 
```java
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
```

위 내용에서 @Filter 로 등록된 클래스는 빈으로 등록하지 않겠다는 의미가 된다. 즉, 스캔하지 않겠다.

'@ComponentScan' 이라는 애는 자기 위치를 시작점으로 하여 하위에 위치해 있는 모든 패키지를 돌며 @Component 라는 애노테이션이 붙은 클래스를 스캔을 한다. 

@Component 를 포함하고 있는 @Configuration, @Repository, @Service, @Controller, @RestController 애노테이션 역시 스캔 대상이 된다.

따라서

### Application.class
```java
@ComponentScan
@Configuration
public class Application {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(Application.class);
        application.run(args);
    }
}
```

이 위치에 @ComponentScan 을 붙이게 되면 이 Application.class 가 위치하고 있는 패키지 부터 해서 모든 패키지를 돌며 컴포넌트를 스캔하게 된다. 그리고 자기 자신도 @Configuration 애노테이션이 붙어있기 때문에 빈으로 등록이 된다.

따라서 가령 me.waggs 와 동등한 hierarcy 에 있는 me.lee 의 패키지에 컨트롤러나 서비스를 생성하여 애노테이션을 달아주더라도 @ComponentScan 이 붙어있는 Application.class 의 패키지 밖이기 때문에 이는 빈으로 등록이 되지 않는다.

그럼 '@EnableAutoConfiguration' 은 뭘 읽어들이는 것일까?

스프링 메타파일을 읽어온다.

 * @EnableAutoConfiguration 
   * spring.factories
     * org.springframework.boot.autoconfigure.EnableAutoConfiguration 이 key 값으로 등록된 value 이 꽤나 많은데 이것들을 자동으로 '@EnableAutoConfiguration' 이 등록해 주는 것이다. 기본 설정들이자 스프링 부트 설정때 다뤘던 'convention' 들이다.
   * __@Configuration__ 은 __빈을 등록하는 자바 설정파일__ 이다. 이 EnableAutoConfiguration의 key 값 밑에 설정된 자바 설정파일들 즉, 클래스들을 모두 다 읽어 들인다.  

   * 그런데, @ConditionalOnXxxYyyZzz 이렇게 'Conditional~~' 로 시작하는 애노테이션들이 많이 사용된다. 이는 조건에 따라 특정 빈을 등록하거나 말거나를 결정하거나 조건에 따라 설정파일을 적용하거나 말거나 처럼 조건부로 작동시키겠다는 것이다.

참고) Servlet : Servlet API. 자바의 서블릿.
     DispatcherServlet : Spring Web MVC 모듈에 있는 것.



그래서 요약하자면 __'@SpringBootApplication' 안에 있는 '@EnableAutoConfiguration' 하나로 spring.factories 내부의 자동 설정들이 조건에 따라 적용이 되어 수 많은 빈들이 생성이 되기 때문에 웹 애플리케이션이 작동을 하게 되는 것이다.__ 

---

## 10.자동설정만들기 1부: Starter와 Autoconfigure

이번엔 커스텀한 AutoConfiguration 을 만들어 보면서 어떻게 동작하는지 살펴본다.

https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-developing-auto-configuration

  * Xxx-Spring-Boot-Autoconfigure 모듈 : 자동 설정

  * Xxx-Spring-Boot-Starter 모듈 : 필요한 의존성 정의(pom file이 핵심)

  * 그냥 하나로 만들고 싶을 때는?
    * Xxx-Spring-Boot-Starter : 자동 설정도 여기에 걍 때려박음

  * 구현방법
    
    1.의존성 추가
    ```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure-processor</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
    <!--위 두 의존성들의 버전 관리를 위해 의존성을 관리하는 dependencyManagement 를 추가함.-->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.0.3.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    ```

    2.@Configuration 파일작성

    ### me.waggs.Holoman.class  // 설정의 대상이 되는 파일
    ```java
    public class Holoman {
        String name;
        int howLong;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getHowLong() {
            return howLong;
        }
 
        public void setHowLong(int howLong) {
            this.howLong = howLong;
        }

        @Override
        public String toString() {
            return "Holoman{" +
                    "name='" + name + '\'' +
                    ", howLong=" + howLong +
                    '}';
        }
    }
    ```

    ### me.waggs.HolomanConfiguration.class   // 자동 설정 파일
    ```java
    //HolomanConfiguration 은 Holoman 을 자동 설정 해주기 위한 설정 파일이다.
    //보통 설정 하는 대상이 되는 Holoman 과 이것에 대한 자동 설정 파일은 서로 다른 프로젝트에 있는게 일반적이다.
    //하지만 편의상 하나에 만든 것.

    @Configuration
    public class HolomanConfiguration {
        @Bean
        public Holoman holoman() {
            Holoman holoman = new Holoman();
            holoman.setHowLong(5);
            holoman.setName("waggs");

            return holoman;
        }
    }
    ```

    3.src/main/resource/META-INF에 spring.factories 파일만들기

    4.spring.factories 안에 자동 설정 파일 추가

    ### src/main/resource/META-INF 아래 spring.factories 파일    
    
    ``` java
    //# 이렇게 resources.META-INF 아래에 spring.factories 파일을 만들어 사용하는 것은 \
    //# 스프링 부트만의 이야기가 아니라 스프링 에서도 쓰이는 방식이다.
    //# 여기에 이렇게 만들어 둔 설정 파일을 명시해 주면
    //# 'org.springframework.boot.autoconfigure.EnableAutoConfiguration' 이 키에 해당하는 value 로
    //# 아래의 설정 파일을 읽어오게 된다.
    org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
    me.waggs.HolomanConfiguration
    ```
    
    5.mvn install

    mvn install 하면 이 프로젝트를 빌드해서 jar 파일 생성된 것을 다른 메이븐 프로젝트에서도 가져다 쓸 수 있도록 로컬 메이븐 저장소에 설치하게 된다.

    이렇게 하면 자동 설정 파일이 완성 됨.


  이렇게 하고 기존 원래 프로젝트로 돌아와서 이 설정 파일을 읽어 들이는 작업을 해 주면 된다.

  ```xml
        <dependency>
            <groupId>me.waggs</groupId>
            <artifactId>waggs-spring-boot-starter</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
  ```
  
  만들어 둔 설정 파일을 기존 프로젝트에서 의존성으로 추가 해준다.

<img width="478" alt="HolomanConfiguration" src="https://user-images.githubusercontent.com/35681772/62179584-05752c00-b388-11e9-9f47-b86702efcde8.png">

그럼 위와 같이 의존성이 들어온 것을 확인할 수 있음.

### HolomanRunner.class
```java
//ApplicationRunner 인터페이스를 구현해 줌. 얘는 원래 Argument 인자를 받아 무엇인가를 하고 싶을 때
//SpringBootApplication 이 만들어지고 떴을 때 자동으로 실행되는 빈을 만들고 싶은 경우 사용한다.
@Component
public class HolomanRunner implements ApplicationRunner {

    @Autowired
    Holoman holoman;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println(holoman.toString());
    }
}
```

기존 프로젝트 어떤 곳에서도 Holoman 이라는 클래스를 정의해 준 적이 없다. 하지만 @Autowired 로 주입을 받고 있고, 그 아래 run 에서 holoman 클래스에 대한 정보를 출력하고 있다.

만약 빈으로 등록이 되어 있다면 로그가 잘 출력될 것이지만, 그렇지 않다면 애플리케이션이 잘 뜨지도 않고 에러가 날 것임.

> Holoman{name='waggs', howLong=5}

이렇게 잘 나오는 것을 확인할 수 있다. 즉, AutoConfiguration 으로 등록이 잘 되었다는 얘기다.

그런데 문제가 있다.

```java
//@SpringBootApplication
@ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(Application.class);
        application.setWebApplicationType(WebApplicationType.NONE);
        application.run(args);
    }

    @Bean
    public Holoman holoman() {
        Holoman holoman = new Holoman();
        holoman.setName("waggs");
        holoman.setHowLong(60);
        return holoman;
    }
}
```

이렇게 내가 또 다시 빈으로 등록을 하려 하면 기대하는 값은 howLong 이 60인 holoman 이다. 하지만 아래와 같은 오류가 나게 된다.

> ***************************
>
> APPLICATION FAILED TO START
> 
> ***************************
> 
> Description:
> 
> The bean 'holoman', defined in me.waggs.Application, could not be registered. A bean > with that name has already been defined in class path resource [me/waggs/> HolomanConfiguration.class] and overriding is disabled.
> 
> Action:
> 
> Consider renaming one of the beans or enabling overriding by setting > spring.main.allow-bean-definition-overriding=true

이를 어떻게 해결할 지 알아보자.

---

## 11.자동설정만들기 2부: @ConfigurationProperties

위의 에러가 난 이유는 얘기는 AutoConfiguration 의 빈이 더 우선시 됐기 때문이다.

따라서 ComponentScan 의 빈 들이 항상 우선시 되도록 설정해 줘야 한다.

  * 덮어쓰기 방지하기
    * @ConditionalOnMissingBean

### HolomanConfiguration.class
```java
@Configuration
public class HolomanConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public Holoman holoman() {
        Holoman holoman = new Holoman();
        holoman.setHowLong(5);
        holoman.setName("waggs");

        return holoman;
    }
}
```

'@ConditionalOnMissingBean' 을 사용해 주면 된다. 이렇게 되면, __해당 타입의 빈이 없을 때만 해당 빈을 등록해라__ 라고 설정해 주는게 된다.

즉, ComponentScan 으로 동일한 빈을 먼저 등록하게 되었다면 AutoConfiguration 으로는 해당 빈을 등록하지 않게 되는 것이다.

Configuration 프로젝트에서는 'install' 을 다시 해 줘야 하고, 설정 파일이 적용될 프로젝트에서는 maven refresh 를 해 줘야 한다.

결국 이렇게 해도 안되어 `spring.main.allow-bean-definition-overriding=true` 이 설정을 application.properties 파일에 줬음.

이런식으로 스프링 부트가 제공해 주는 기능을 커스터마이징 할 수 있다. 이게 기본적인 방법이 된다.


근데 한 가지 의문점이 든다. 내가 위에 정의한 것처럼 빈 설정을 굳이 장황하게 또 overriding 해 주어야 하는가? 

<br>

  * 빈 재정의 수고 덜기
    * @ConfigurationProperties(“holoman”)
    * @EnableConfigurationProperties(HolomanProperties)
    * 프로퍼티키값자동완성

이렇게 resources > application.properties 파일을 생성하고 여기에 

### application.properties
```
spring.main.allow-bean-definition-overriding=true

holoman.name = callmewaggs
holoman.how-long = 55
```

위와 같이 properties 파일을 생성해서 값을 준다. 그리고 이 properties 를 사용하려면 자동 완성 설정 파일에 새로운 클래스를 하나 만들어 주고 @ConfigurationProperties("holoman") 애노테이션을 붙여주면 된다.

근데 이렇게 까지 하면 IDE 상에서 경고가 나옴. 위 애노테이션을 사용하려면 아래 의존성을 추가해 줘야 한다는 것.

따라서 pom.xml 에 아래 의존성을 추가해주자.

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-configuration-processor</artifactId>
	<optional>true</optional>
</dependency>
```

설정 파일이 적용될 프로젝트에서 해당 빈을 등록하지 않는다면, 설정 파일에서 AutoConfiguration 에서 빈을 만들도록. 근데 그 때 holomanProperties 를 참조해서 빈으로 등록하게 해 주는 것이다.

즉, properties 를 써서 빈으로 등록하는 것이다. 빈을 재 정의하지 않고 properties 만 가져다 쓰는 것이다.

이걸 @EnableConfigurationProperties(HolomanProperties.class) 애노테이션을 붙혀 나타내 준다.

```java
@Configuration
@EnableConfigurationProperties(HolomanProperties.class)
public class HolomanConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public Holoman holoman(HolomanProperties holomanProperties) {
        Holoman holoman = new Holoman();
        holoman.setHowLong(holomanProperties.getHowLong());
        holoman.setName(holomanProperties.getName());

        return holoman;
    }
}

```

이렇게 만들어 주고 다시 자동 설정 프로젝트에서 mvn install 한 뒤 적용될 프로젝트에서 reimport 해 주면 된다.

---

## 12.내장 웹 서버 이해

  * 스프링 부트는 서버가 아니다.
    * 톰캣 객체 생성
    * 포트 설정
    * 톰캣에 컨텍스트 추가
    * 서블릿 만들기
    * 톰캣에 서블릿 추가
    * 컨텍스트에 서블릿 맵핑
    * 톰캣 실행 및 대기
  
```java
public class Application {

    public static void main(String[] args) {
        SpringApplication application = new SpringApplication(Application.class);
//      이렇게 웹 애플리케이션 타입을 NONE 으로 주고 애플리케이션을 실행 하면 웹 서버가 뜨지 않게 된다.
//      즉, 스프링은 웹 서버 가 아니라는 것!!!
//      스프링 부트 자체는 서버가 아니고 '툴' 이다. 
//      내장 서블릿 컨테이너를 쉽게 사용하게 해 주는 툴, 스프링 프레임 워크를 쉽게 사용하게 해 주는 툴 이다.
//      '서버' 라 함은 '톰캣', '네티', '제티', '언더토우' 등이 해당 된다.
//      그리고 위 '서버' 들은 자바 코드로 서버를 만들 수 있는 기능을 제공한다.
        application.setWebApplicationType(WebApplicationType.NONE);
        application.run(args);
    }
}
```
스프링은 웹 서버 가 아니다!!! 스프링 부트 자체는 서버가 아니고 '툴' 이다. 

내장 서블릿 컨테이너를 쉽게 사용하게 해 주는 툴, 스프링 프레임 워크를 쉽게 사용하게 해 주는 툴 이다.

'서버' 라 함은 '톰캣', '네티', '제티', '언더토우' 등이 해당 된다. 그리고 이 '서버' 들은 자바 코드로 서버를 만들 수 있는 기능을 제공한다.

기본적으로 스프링 부트 애플리케이션을 만들면 의존성으로 '톰캣'이 들어오게 된다. 'External Libraries' 에 확인해 보면 있음.

그래서 자바 코드로 '톰캣'을 만들 수도 있다.

### Application.class
```java
public class Application {

    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        tomcat.setPort(8080);
        // 톰캣에  Context를 추가 해 줘야 한다. 인자로는 contextPath, documentBase 순
        Context context = tomcat.addContext("/", "/");

        HttpServlet servlet = new HttpServlet() {
            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                PrintWriter writer = resp.getWriter();
                writer.println("<html><head><title>");
                writer.println("Hey, Tomcat");
                writer.println("</title></head>");
                writer.println("<body><h1>Hello Tomcat</h1></body><html>");
            }
        };

        String servletName = "helloServlet";
        // contextPath, servletName, servlet 이 순서. servlet 을 servletName 으로 context 에다 추가하는 것.
        tomcat.addServlet("/", servletName, servlet);
        // 아래 인자로 첫 번째 인자는 '어떤 요청(URL)이 왔을때' 두 번째 인자 '어떤 서블릿을 보여 줄 것이냐' 이다.
        context.addServletMappingDecoded("/hello", servletName);

        tomcat.start();
        // 아래 처럼 await() 을 주면 톰캣을 시작하고 기다린다. 그냥 start() 에서 끝내버리면 시작한 뒤 바로 끝낸다.
        tomcat.getServer().await();
    }
}
```

위와 같이 하면 톰캣에 서블릿을 사용해 html 을 띄울 수 있게 된다.

하지만 위의 설정은 내가 스프링 부트에서 앞으로 쓰게 될 기능들은 아니다. 이런 기능은 스프링 부트에서 다음과 같이 지원해 주고 있다.

스프링 부트에서는 어떻게 서블릿 컨테이너를 띄워 주는 것인가???

이는 앞서 본 '자동 설정'과 관련이 있다. 위의 톰캣에 관련된 설정과 서블릿 설정이 '자동 설정'으로 자동으로 설정이 되게 된다. 그래서 스프링 부트 애플리케이션을 실행하면 톰캣이 만들어지고 서블릿이 추가가 되고 웹 MVC 설정이 다 되고 ... 애플리케이션이 뜨는 것이다. 

내장 톰캣의 설정 또한 '자동 설정'의 일부다.

들어와 있는 메이븐 의존성 중에서 autoconfigure > META-INF > spring.factories 를 열어보면 

  * 이 모든 과정을 보다 상세히 또 유연하고 설정하고 실행해주는게 바로 스프링 부트의 자동 설정.
    * ServletWebServerFactoryAutoConfiguration (서블릿 웹 서버를 생성하는 자동 설정)
      * TomcatServletWebServerFactoryCustomizer (서버 커스터마이징)
    * DispatcherServletAutoConfiguration
      * 서블릿 만들고 등록

위 파일들을 직접 들어가 보며 확인 할 수 있는데.. 복잡하기 때문에 __자동 설정으로 톰캣이 만들어 지고, 내장 서블릿 컨테이너가 만들어 진다.__ 이 정도만 알고 넘어가면 된다.

그러면 위에서 __직접 만들었던 서블릿은 어떻게 생성이 되는가? 서블릿 기반의 MVC 라면 DispatcherServlet 을 만들어 줘야 한다.__ 

다시 autoconfigure 설정 파일을 들어가 보면.. 'DispatcherServletAutoConfiguration' 이라는 곳에서 서블릿을 생성하고 등록해 주고 있는것을 확인할 수 있다. 

그렇다면 이 둘은 왜 떨어져 있는가? pom.xml 에 해 줄 설정에 따라 서블릿 컨테이너는 다 달라질 수 있다. 하지만 서블릿은 변하지 않는다. 그렇기 때문에 DispatcherServlet은 어떠한 서블릿 컨테이너를 쓰던 무관하게 서블릿을 만든 다음 현재 쓰고 있는 서블릿 컨테이너에 등록을 하게 된다.

__위에 작성한 코드로 내장 톰캣을 만들고 서블릿을 등록할 수 있는데, 이런 과정이 '자동 설정'에서는 'ServletWebServerFactoryAutoConfiguration' 와 'DispatcherServletAutoConfiguration' 로 둘로 나뉘어서 자동으로 설정이 되는구나!!!__ 정도로 이해하고 넘어가면 된다.

그럼 이 설정들을 어떻게 하면 잘 사용할 수 있을지에 대해 알아보자.

---

## 13.내장 웹 서버 응용 1부: 컨테이너와 서버 포트

내장 서블릿 컨테이너를 응용해서 사용하는 방법에 대해 알아본다.

스프링 부트에선 서블릿 기반의 웹 MVC 어플리케이션을 개발할 때 기본적으로 '톰캣'이 의존성으로 들어오게 된다. 앞서 살펴본 '자동 설정'에 의해서.

이 '자동 설정'에 의해서 톰캣 용 자동 설정 파일이 읽혀지고 톰캣이 만들어지고, 그래서 톰캣을 사용하게 되는 것이다.

그럼 다른 서블릿 컨테이너를 사용하려면 어떻게 할까?

https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html

 * 다른 서블릿 컨테이너로 변경 - 'spring-boot-starter-web' 이 'spring-boot-starter-tomcat'을 가져오기 때문에 'spring-boot-starter-web'을 먼저 빼 줘야 한다.

 ```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
 ```

'spring-boot-starter-web' 에서 'spring-boot-starter-tomcat'을 exclusion 하겠다 고 적어주는 것이다.
 
그리고 새로운 서블릿 컨테이너로 jetty 를 넣어주겠다고 아래에 의존성을 넣어준 것.

<img width="495" alt="dependency-jetty" src="https://user-images.githubusercontent.com/35681772/62341626-01c7dd80-b51f-11e9-997c-24b914fb1cfa.png">

그러면 이렇게 tomcat 이 빠지고 jetty 가 의존성으로 들어와 있는것을 확인할 수 있다.

이러고 실행을 해 보면 jetty 가 8080포트에 떴다고 로그가 찍히게 된다.

 * 웹 서버 사용하지 않기

의존성으로 웹 관련된 의존성이 들어와 있으면 스프링은 자동으로 웹 애플리케이션으로 만들려고 시도한다. 이거를 전에 main함수에서 WebApplicationType 을 NONE 으로 셋팅하여 그렇지 않도록 설정했는데, application.properties 로도 수정할 수 있다.

application.properties 에 ```spring.main.web-application-type=none```

이렇게 추가 해 주면 된다. 그럼 웹 서블릿 컨테이너 의존성이 있다 하더라도 무시하고 NONE web application으로 실행하고 끝나게 된다.

 * 포트
   * server.port 

    application.properties 에 ```server.port=7070``` 추가하여 웹 서버 포트를 변경할 수 있다.

   * 랜덤 포트

    application.properties 에 ```server.port=0``` 이렇게 0을 주면 웹 서버 포트를 랜덤으로 잡아서 띄운다.

   * ApplicationListner<ServletWebServerInitializedEvent>

    그럼 이렇게 랜덤하게 또는 고정시킨 포트를 애플리케이션에서 어떻게 쓸 것이냐? 
    
    먼저 EventListener 역할을 할 빈을 하나 생성한다.

    ### PortListener.class
    ```java
    // ServletWebServerInitializedEvent 이 이벤트는 웹 서버가 생성이 되면 호출이 된다.
    @Component
    public class PortListener implements       ApplicationListener<ServletWebServerInitializedEvent> {
        // 그럼 여기서 어떻게 포트정보를 알아낼 수 있을까?
        @Override
        public void onApplicationEvent(ServletWebServerInitializedEvent event) {
            // 먼저 이벤트에서 applicationContext 를 꺼낸다.
            ServletWebServerApplicationContext applicationContext =        event.getApplicationContext();
            // 서블릿 웹 서버 애플리케이션 컨텍스트기 때문에 웹 서버를 알 수 있고, 그 웹 서버를 통해 포트를 알 수      있다.
            System.out.println(applicationContext.getWebServer().getPort());
        }
    }
    ```

---

## 14.내장 웹 서버 응용 2부: HTTPS와 HTTP2

내장 서블릿 컨테이너(내장 웹 서버)에 HTTPS 와 HTTP2를 적용하는 방법에 대해 알아본다.

https://opentutorials.org/course/228/4894

https://gist.github.com/keesun/f93f0b83d7232137283450e08a53c4fd

 * HTTPS 설정하기
   * 키스토어 만들기 : HTTPS 를 설정하려면 키스토어를 만들어야 한다.
   * HTTP는 못쓰네?

```
waggs-MacBook-Pro:springbootgettingstarted waggs$ keytool -genkey -alias spring -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 4000
```

이렇게 명령어를 입력하고 ls를 해 보면 keystore 가 생긴 것을 알 수 있다.
생성된 keystore 로 셋팅을 시작하면 된다.

application.properties 에서 

```
server.ssl.key-store=keystore.p12
server.ssl.key-store-type=PKCS12
server.ssl.key-store-password=123456
server.ssl.key-alias=spring
```

이렇게 입력해 주고 애플리케이션을 실행해보면 된다. 

스프링 부트는 톰캣이 사용하는 커넥터가 기본적으로 하나만 제공이 된다. 그 커넥터에 SSL 을 적용을 해 주게 된다. 그래서 앞으로 모든 요청은 다 HTTPS 를 붙혀서 해야한다.

따라서 localhost:8080 으로 접속 해 보면 접속이 안된다. https://localhost:8080 으로 요청시 

<img width="1673" alt="https://localhost:8080" src="https://user-images.githubusercontent.com/35681772/62343806-79e5d180-b526-11e9-836b-e3bad8092956.png">

이런 화면이 뜬다. 왜? 브라우저(클라이언트)가 서버에 요청을 보냈을떄 서버에서 내가 만든 인증서를 보내게 된다.

이 인증서는 keystone 안에 들어있는데, 브라우저는 그 인증서의 pub key 를 모르는 상황이라 이런 화면이 뜨게 된다.

공인된 인증서들에 대한 pub key 는 대부분의 브라우저들이 알고 있기 떄문에 이런 화면이 뜨지 않고 Not Sequre 부분이 '초록색' 으로 나타나게 된다.

근데 내가 만든 인증서는 브라우저가 전혀 모르는 인증서라서 위와 같은 Not Secure 가 나타나게 되는 것이다.

즉, 공식적으로 발급된 인증서가 아닌데도 방문 할 것이냐 를 물어보는 화면인 것임. 그냥 무시하고 들어가 보면 된다.

다음으로 터미널에서 ```curl -k -I --http2 https://localhost:8080/hello``` 를 입력하면 curl 로 요청했을 때 다음과 같이 나오게 된다.

> HTTP/1.1 200 
>
> Content-Type: text/plain;charset=UTF-8
>
> Content-Length: 12
>
> Date: Fri, 02 Aug 2019 04:15:41 GMT

이러면 위와 같이 200 이 뜨게 된다.

프로토콜을 보면 위 명령어에서 http2 로 요청을 해도 http1.1 로 받고 있는것을 확인할 수 있다. 

HTTPS 를 적용하고 나면 더이상 HTTP 는 사용할 수 없다. 기본적으로 톰캣은 커넥터가 하나라서 그 하나를 HTTPS 에 줬기 때문에 HTTP를 설정 할 커넥터가 더이상 없게 된 것이다.

이걸 다시 설정하는 방법?

 * HTTP 커넥터는 코딩으로 설정하기
   * https://github.com/spring-projects/spring-boot/tree/v2.0.3.RELEASE/spring-boot-samples/spring-boot-sample-tomcat-multi-connectors

### Application.class
```java
@SpringBootApplication
@RestController
public class Application {

    @GetMapping("/hello")
    public String hello() {
        return "Hello Spring";
    }

    @Bean
    public ServletWebServerFactory serverFactory() {
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
        tomcat.addAdditionalTomcatConnectors(createStandardConnector());
        return tomcat;
    }

    private Connector createStandardConnector() {
        Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
        connector.setPort(8080);
        return connector;
    }


    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

이렇게 셋팅해주면 커넥터가 두개가 된다. 8080은 HTTPS 를 받고, 8443은 HTTP를 받게 된다.


 * HTTP2 설정
   * server.http2.enable : application.properties 에 이 설정을 true로 주면 된다.
   * 근데 사용하는 서블릿 컨테이너 마다 다름. 

undertow 는 아무런 설정을 해 주지 않아도 됨. 위 처럼 true 만 주면 끝난다.

반면 톰캣은 8.x 대의 버전에선 꽤나 복잡하다. 9.x 대의 버전은 마찬가지로 위 옵션만 주면 된다.

__HTTP2 를 쓰려면 SSL이 기본적으로 적용이 되어 있어야 한다.__

따라서 undertow로 서블릿 컨테이너를 변경해 준 다음 위의 enable 설정을 true 로 주고

```curl -k -I --http2 https://localhost:8443/hello``` 입력해 보면 HTTP2가 뜨는걸 확인할 수있다.

 > HTTP/2 200 
 >
 > content-type: text/plain;charset=UTF-8
 >
 > content-length: 12
 >
 > date: Fri, 02 Aug 2019 06:07:54 GMT

---

15.톰캣 HTTP2

 * JDK9와 Tomcat 9+ 추천
 * 그 이하는 아래 링크 참고

https://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-web-servers.html#howto-configure-http2-tomcat

별 설정 없이 기존에 undertow 와 exclusion 으로 톰캣 제외해준 것 원래대로 돌려놓고 위 curl 명령어를 입력해서 HTTP2 요청을 보내보니 아래처럼 잘 나왔음.

> HTTP/2 200 
>
> content-type: text/plain;charset=UTF-8
>
> content-length: 12
> date: Sat, 03 Aug 2019 03:46:04 GMT

---

## 16.독립적으로 실행 가능한 JAR

https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html

다음으로 다룰 내용은 스프링 부트 내용이지만 '메이븐 플러그인'에 더 가까운 내용이다.

이 애플리케이션을 개발을 할 땐 IDE에서 실행을 한다. 하지만 이 앱을 어딘가에 __배포하거나 도커 이미지로 만들거나 할 때는 jar 패키지로 패키징 한 다음 그 jar 파일을 실행하는 방법이 매우 유용하다.__

이 부분이 스프링 부트의 중요한 특징 중 하나가 된다.

### Application.class
```java
@SpringBootApplication
@RestController
public class Application {

    @GetMapping("/hello")
    public String hello() {
        return "Hello Spring";
    }

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

이걸 이제 IDE 상에서 실행한 뒤 localhost:8080/hello 로 요청을 보내면 "Hello Spring" 이 잘 나오는 것을 확인할 수 있다.

이걸 터미널에서 ```mvn clean package``` 해서 깔끔하게 밀어준다.

```mvn clean {target}``` : target 밑에 있는것 모두를 삭제. 따라서 target 에 package를 줬으므로 패키지를 밀어버리는 명령어임.

그 다음 ```mvn package -DskipTest``` 로 테스트는 제외한 채 패키징을 한다.

그러고 나면 'target' 디렉토리에 .jar 파일이 하나 생기게 된다.

```springinit-0.0.1-SNAPSHOT.jar```

이 jar 파일은 이거 하나만 있어도 앱이 돌아간다.

```waggs-MacBook-Pro:target waggs$ java -jar springinit-0.0.1-SNAPSHOT.jar```

이렇게 명령어 쳐 보면 IDE 상에서 시작을 누른것 처럼 앱이 돌아가게 된다.

__그럼 자동 생성 되었거나 내가 추가한 수 많은 의존성들은 어떻게 될까??__

“그러고보니 JAR 파일 하나로 실행할 수 있네?”

  * mvn package를 하면 실행 가능한 ​__JAR 파일 “하나가"​__ 생성됨. __그 JAR 파일 안에 모든 의존성들이 다 들어가 있다.__

  * spring-maven-plugin이 해 주는일 (패키징)
  
```
waggs-MacBook-Pro:target waggs$ pwd
/Users/waggs/Documents/Inf/Spring_Boot_Concepts_and_Application/springinit/target
waggs-MacBook-Pro:target waggs$ mkdir app
waggs-MacBook-Pro:target waggs$ ls
app                                     generated-sources                       maven-archiver                          springinit-0.0.1-SNAPSHOT.jar           surefire-reports
classes                                 generated-test-sources                  maven-status                            springinit-0.0.1-SNAPSHOT.jar.original  test-classes
waggs-MacBook-Pro:target waggs$ cp ./springinit-0.0.1-SNAPSHOT.jar ./app
waggs-MacBook-Pro:target waggs$ cd app/
waggs-MacBook-Pro:app waggs$ ls
springinit-0.0.1-SNAPSHOT.jar
waggs-MacBook-Pro:app waggs$ unzip -q springinit-0.0.1-SNAPSHOT.jar 
waggs-MacBook-Pro:app waggs$ ls
BOOT-INF                        META-INF                        org                             springinit-0.0.1-SNAPSHOT.jar
waggs-MacBook-Pro:app waggs$ 
```

```unzip -h``` 와 같이 입력하면 옵션들을 확인할 수 있다. ```unzip -q``` 옵션을 줘서 빨리풀기로 압축을 해제하였다.

해제된 폴더들을 들어가보면 'BOOT-INF>classes' 에 내가 만든 파일들이 들어가 있고, 'BOOT-INF>lib'에 앞서 말한 의존성들이 전부 다 포함되어 있다. 즉, 앱에 필요한 모든 라이브러리들이 다 들어있다는 것.

JAR 파일 하나에 모든 것들이 다 들어있다는 것이다. 그래서 앱에 필요한 것은 모두 들어가 있는게 된다.

근데 자바에는 JAR 안에 들어 있는 JAR 파일을 읽을 수 있는 표준적인 방법이 없다. 그래서

  
  * 과거 “uber” jar 를 사용
     * 모든 클래스 (의존성 및 애플리케이션)를 하나로 압축하는 방법 
     * 뭐가 어디에서 온 건지 알 수가 없음
       * 무슨 라이브러리를 쓰는건지..
     * 내용은 다르지만 이름이 같은 파일은 또 어떻게?

그래서 스프링 부트가 들고 나온 해법은 

  * 스프링 부트의 전략
     * 내장 JAR : 기본적으로 자바에는 내장 JAR를 로딩하는 ​__표준적인 방법이 없음​.__ 
     * 애플리케이션 클래스와 라이브러리 위치 구분
     * org.springframework.boot.loader.jar.JarFile을 사용해서 내장 JAR를 읽는다.
     * org.springframework.boot.loader.Launcher를 사용해서 실행한다.

즉, JAR 안에 JAR 파일을 다 묶어 놓는다. 그리고 이걸 org 폴더에 JAR 파일을 '읽을 수 있도록' 파일을 만들어 둔다.

어떤 파일이냐면 가령 org>...>jar 에 가 보면 JarFile.class 얘가 JAR 파일들을 읽는 역할을 한다. 

또한 org>...>Launcher 얘는 우리가 가지고 있는 메인 메소드를 가지고 있는 메인 어플리케이션을 실행하는 역할을 담당한다. JAR 파일의 경우 JarLauncher.class 를 사용.

__이런게 있어서 JAR 파일 하나로도 동작을 하고, JAR 파일 안에 이런 형태로 묶어 놨기 때문에 하나만으로도 동작을 하는구나! 라고 알면 된다.__

스프링 부트의 주요 목표중 하나가 '독립적으로 실행 가능한 애플리케이션' 이었는데 이를 위와 같은 방법으로 스프링은 편의를 제공해 주고 있다.

그래서 '메이븐'이 jar 파일로 패키징을 해주고, 그 안의 MANIFEST.MF 의 정보를 이용해서 모든 일 들이 벌어지게 되는 것이다. MANIFEST.MF 부터 시작한다는 것이다.

모든 JAR 파일의 시작점은 MANIFEST.MF 가 된다.

### MANIFEST.MF
```
Manifest-Version: 1.0
Created-By: Maven Archiver 3.4.0
Build-Jdk-Spec: 12
Implementation-Title: springinit
Implementation-Version: 0.0.1-SNAPSHOT
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: me.waggs.springinit.SpringinitApplication
Spring-Boot-Version: 2.1.6.RELEASE
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
```

MANIFEST.MF 의 Main-Class 가 모든 JAR 파일의 시작점이 된다. 이것은 자바의 스펙인데, 이 이후부터 스프링이 이를 수정하여 개선한 것.

---

## 17.스프링 부트 원리 정리

  * 의존성 관리 - pom.xml 파일
    * 이것만 넣어도 이만큼이나 다 알아서 가져오네?

    pom 파일 안에 dependency 들. 'spring-boot-starter-web' 만 들어가도 엄청난 양의 의존성이 들어오게 된다. 이게 바로 'starter' 의 역할이다. 의존성을 관리해 주는 역할.

    메이븐에서 이 의존성들이 관리를 받는 방법은 'parent' 개념. 최상위엔 'spring-boot-dependencies' 가 있다.

  * 자동 설정
    * @EnableAutoConfiguration이 뭘 해주는지 알겠어.

    @SpringBootApplication 이라는 애노테이션에 보면 @EnableAutoConfiguration 이 있고, @ComponentScan 이 있다. 

    스프링 부트는 두 단계에 나눠서 빈을 등록하게 된다. 첫 번째 단계에서 ComponentScan 에서 빈을 스캔해서 등록하는 단계이고, 두 번째 단계에서는 자동 설정을 시작한다. 그 과정에서 기존 등록된 빈들을 참고해서 빈 등록 여부를 결정한다. 가령 @Conditional... 과 같은 애노테이션에 잘 나타나 있음.

    그리고 자동 설정에 대한 properties 파일을 참고도 한다.

    스프링 부트의 주요한 목표 중 하나가 stand-alone application 을 만들어 주는 것이다. 그래서 이렇게 많은 자동 설정들이 starter 만 의존성으로 추가해 주더라도 그 많은 의존성들이 추가되는 것이다.

  * 내장웹서버
    * 아 스프링 부트가 서버가 아니라 내장 서버를 실행하는 거군.

    서버는 톰캣, 제티, 네티, 언더토우, ... 이것들이 서블릿 컨테이너 또는 리액티브 서버 역할을 하는 것이다. 스프링은 이들을 활용을 할 뿐.

  * 독립적으로 실행 가능한 JAR
    * spring-boot-maven 플러그인이 이런걸 해주는구나..